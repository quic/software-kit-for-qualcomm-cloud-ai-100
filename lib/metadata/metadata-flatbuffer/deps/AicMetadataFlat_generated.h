// Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
// SPDX-License-Identifier: BSD-3-Clause-Clear

// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_AICMETADATAFLAT_AICMETADATAFLAT_H_
#define FLATBUFFERS_GENERATED_AICMETADATAFLAT_AICMETADATAFLAT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
                  FLATBUFFERS_VERSION_MINOR == 0 &&
                  FLATBUFFERS_VERSION_REVISION == 8,
              "Non-compatible flatbuffers version included");

namespace AicMetadataFlat {

struct execContext;
struct execContextBuilder;
struct execContextT;

struct execContextField;

struct AICMDSemaphoreOp;
struct AICMDSemaphoreOpBuilder;
struct AICMDSemaphoreOpT;

struct AICMDDoorbellOp;
struct AICMDDoorbellOpBuilder;
struct AICMDDoorbellOpT;

struct AICMDDMARequest;
struct AICMDDMARequestBuilder;
struct AICMDDMARequestT;

struct AICMDNSPMulticastEntry;
struct AICMDNSPMulticastEntryBuilder;
struct AICMDNSPMulticastEntryT;

struct AICMDNSPMulticastEntryTable;
struct AICMDNSPMulticastEntryTableBuilder;
struct AICMDNSPMulticastEntryTableT;

struct AICMDHostMulticastEntry;
struct AICMDHostMulticastEntryBuilder;
struct AICMDHostMulticastEntryT;

struct AICMDHostMulticastEntryTable;
struct AICMDHostMulticastEntryTableBuilder;
struct AICMDHostMulticastEntryTableT;

struct AICMDThreadDescriptor;
struct AICMDThreadDescriptorBuilder;
struct AICMDThreadDescriptorT;

struct AICMDConstantMapping;
struct AICMDConstantMappingBuilder;
struct AICMDConstantMappingT;

struct Metadata;
struct MetadataBuilder;
struct MetadataT;

enum execContextVariables : int8_t {
  execContextVariables_network_execution_base = 0,
  execContextVariables_port_info = 1,
  execContextVariables_network_heap = 2,
  execContextVariables_MCID_reprog = 3,
  execContextVariables_QNN_dl_support = 4,
  execContextVariables_MIN = execContextVariables_network_execution_base,
  execContextVariables_MAX = execContextVariables_QNN_dl_support
};

inline const execContextVariables (&EnumValuesexecContextVariables())[5] {
  static const execContextVariables values[] = {
      execContextVariables_network_execution_base,
      execContextVariables_port_info, execContextVariables_network_heap,
      execContextVariables_MCID_reprog, execContextVariables_QNN_dl_support};
  return values;
}

inline const char *const *EnumNamesexecContextVariables() {
  static const char *const names[6] = {"network_execution_base", "port_info",
                                       "network_heap",           "MCID_reprog",
                                       "QNN_dl_support",         nullptr};
  return names;
}

inline const char *EnumNameexecContextVariables(execContextVariables e) {
  if (flatbuffers::IsOutRange(e, execContextVariables_network_execution_base,
                              execContextVariables_QNN_dl_support))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesexecContextVariables()[index];
}

enum AICHardwareVersion : int64_t {
  AICHardwareVersion_AIC_HW_VER_1_0 = 65536LL,
  AICHardwareVersion_AIC_HW_VER_2_0 = 131072LL,
  AICHardwareVersion_MIN = AICHardwareVersion_AIC_HW_VER_1_0,
  AICHardwareVersion_MAX = AICHardwareVersion_AIC_HW_VER_2_0
};

inline const AICHardwareVersion (&EnumValuesAICHardwareVersion())[2] {
  static const AICHardwareVersion values[] = {
      AICHardwareVersion_AIC_HW_VER_1_0, AICHardwareVersion_AIC_HW_VER_2_0};
  return values;
}

inline const char *EnumNameAICHardwareVersion(AICHardwareVersion e) {
  switch (e) {
  case AICHardwareVersion_AIC_HW_VER_1_0:
    return "AIC_HW_VER_1_0";
  case AICHardwareVersion_AIC_HW_VER_2_0:
    return "AIC_HW_VER_2_0";
  default:
    return "";
  }
}

enum AICMDSemaphoreOpcode : int8_t {
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdNOP = 0,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdINIT = 1,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdINC = 2,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdDEC = 3,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdWAITEQ = 4,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdWAITGE = 5,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdP = 6,
  AICMDSemaphoreOpcode_MIN = AICMDSemaphoreOpcode_AICMDSemaphoreCmdNOP,
  AICMDSemaphoreOpcode_MAX = AICMDSemaphoreOpcode_AICMDSemaphoreCmdP
};

inline const AICMDSemaphoreOpcode (&EnumValuesAICMDSemaphoreOpcode())[7] {
  static const AICMDSemaphoreOpcode values[] = {
      AICMDSemaphoreOpcode_AICMDSemaphoreCmdNOP,
      AICMDSemaphoreOpcode_AICMDSemaphoreCmdINIT,
      AICMDSemaphoreOpcode_AICMDSemaphoreCmdINC,
      AICMDSemaphoreOpcode_AICMDSemaphoreCmdDEC,
      AICMDSemaphoreOpcode_AICMDSemaphoreCmdWAITEQ,
      AICMDSemaphoreOpcode_AICMDSemaphoreCmdWAITGE,
      AICMDSemaphoreOpcode_AICMDSemaphoreCmdP};
  return values;
}

inline const char *const *EnumNamesAICMDSemaphoreOpcode() {
  static const char *const names[8] = {
      "AICMDSemaphoreCmdNOP",    "AICMDSemaphoreCmdINIT",
      "AICMDSemaphoreCmdINC",    "AICMDSemaphoreCmdDEC",
      "AICMDSemaphoreCmdWAITEQ", "AICMDSemaphoreCmdWAITGE",
      "AICMDSemaphoreCmdP",      nullptr};
  return names;
}

inline const char *EnumNameAICMDSemaphoreOpcode(AICMDSemaphoreOpcode e) {
  if (flatbuffers::IsOutRange(e, AICMDSemaphoreOpcode_AICMDSemaphoreCmdNOP,
                              AICMDSemaphoreOpcode_AICMDSemaphoreCmdP))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDSemaphoreOpcode()[index];
}

enum AICMDSemaphoreSync : int8_t {
  AICMDSemaphoreSync_AICMDSemaphoreSyncPost = 0,
  AICMDSemaphoreSync_AICMDSemaphoreSyncPre = 1,
  AICMDSemaphoreSync_MIN = AICMDSemaphoreSync_AICMDSemaphoreSyncPost,
  AICMDSemaphoreSync_MAX = AICMDSemaphoreSync_AICMDSemaphoreSyncPre
};

inline const AICMDSemaphoreSync (&EnumValuesAICMDSemaphoreSync())[2] {
  static const AICMDSemaphoreSync values[] = {
      AICMDSemaphoreSync_AICMDSemaphoreSyncPost,
      AICMDSemaphoreSync_AICMDSemaphoreSyncPre};
  return values;
}

inline const char *const *EnumNamesAICMDSemaphoreSync() {
  static const char *const names[3] = {"AICMDSemaphoreSyncPost",
                                       "AICMDSemaphoreSyncPre", nullptr};
  return names;
}

inline const char *EnumNameAICMDSemaphoreSync(AICMDSemaphoreSync e) {
  if (flatbuffers::IsOutRange(e, AICMDSemaphoreSync_AICMDSemaphoreSyncPost,
                              AICMDSemaphoreSync_AICMDSemaphoreSyncPre))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDSemaphoreSync()[index];
}

enum AICMDDoorbellOpSize : int8_t {
  AICMDDoorbellOpSize_AICMDDoorballOpSize8 = 0,
  AICMDDoorbellOpSize_AICMDDoorballOpSize16 = 1,
  AICMDDoorbellOpSize_AICMDDoorballOpSize32 = 2,
  AICMDDoorbellOpSize_MIN = AICMDDoorbellOpSize_AICMDDoorballOpSize8,
  AICMDDoorbellOpSize_MAX = AICMDDoorbellOpSize_AICMDDoorballOpSize32
};

inline const AICMDDoorbellOpSize (&EnumValuesAICMDDoorbellOpSize())[3] {
  static const AICMDDoorbellOpSize values[] = {
      AICMDDoorbellOpSize_AICMDDoorballOpSize8,
      AICMDDoorbellOpSize_AICMDDoorballOpSize16,
      AICMDDoorbellOpSize_AICMDDoorballOpSize32};
  return values;
}

inline const char *const *EnumNamesAICMDDoorbellOpSize() {
  static const char *const names[4] = {"AICMDDoorballOpSize8",
                                       "AICMDDoorballOpSize16",
                                       "AICMDDoorballOpSize32", nullptr};
  return names;
}

inline const char *EnumNameAICMDDoorbellOpSize(AICMDDoorbellOpSize e) {
  if (flatbuffers::IsOutRange(e, AICMDDoorbellOpSize_AICMDDoorballOpSize8,
                              AICMDDoorbellOpSize_AICMDDoorballOpSize32))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDDoorbellOpSize()[index];
}

enum AICMDDMAEntryAddrSpace : int8_t {
  AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceMC = 0,
  AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceDDR = 1,
  AICMDDMAEntryAddrSpace_MIN = AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceMC,
  AICMDDMAEntryAddrSpace_MAX = AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceDDR
};

inline const AICMDDMAEntryAddrSpace (&EnumValuesAICMDDMAEntryAddrSpace())[2] {
  static const AICMDDMAEntryAddrSpace values[] = {
      AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceMC,
      AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceDDR};
  return values;
}

inline const char *const *EnumNamesAICMDDMAEntryAddrSpace() {
  static const char *const names[3] = {"AICMDDMAAddrSpaceMC",
                                       "AICMDDMAAddrSpaceDDR", nullptr};
  return names;
}

inline const char *EnumNameAICMDDMAEntryAddrSpace(AICMDDMAEntryAddrSpace e) {
  if (flatbuffers::IsOutRange(e, AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceMC,
                              AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceDDR))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDDMAEntryAddrSpace()[index];
}

enum AICMDDMADirection : int8_t {
  AICMDDMADirection_AICMDDMAIn = 0,
  AICMDDMADirection_AICMDDMAOut = 1,
  AICMDDMADirection_MIN = AICMDDMADirection_AICMDDMAIn,
  AICMDDMADirection_MAX = AICMDDMADirection_AICMDDMAOut
};

inline const AICMDDMADirection (&EnumValuesAICMDDMADirection())[2] {
  static const AICMDDMADirection values[] = {AICMDDMADirection_AICMDDMAIn,
                                             AICMDDMADirection_AICMDDMAOut};
  return values;
}

inline const char *const *EnumNamesAICMDDMADirection() {
  static const char *const names[3] = {"AICMDDMAIn", "AICMDDMAOut", nullptr};
  return names;
}

inline const char *EnumNameAICMDDMADirection(AICMDDMADirection e) {
  if (flatbuffers::IsOutRange(e, AICMDDMADirection_AICMDDMAIn,
                              AICMDDMADirection_AICMDDMAOut))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDDMADirection()[index];
}

enum AICMDMulticastEntryAddrSpace : int8_t {
  AICMDMulticastEntryAddrSpace_AICMDAddrSpaceL2TCM = 0,
  AICMDMulticastEntryAddrSpace_AICMDAddrSpaceVTCM = 1,
  AICMDMulticastEntryAddrSpace_MIN =
      AICMDMulticastEntryAddrSpace_AICMDAddrSpaceL2TCM,
  AICMDMulticastEntryAddrSpace_MAX =
      AICMDMulticastEntryAddrSpace_AICMDAddrSpaceVTCM
};

inline const AICMDMulticastEntryAddrSpace (
    &EnumValuesAICMDMulticastEntryAddrSpace())[2] {
  static const AICMDMulticastEntryAddrSpace values[] = {
      AICMDMulticastEntryAddrSpace_AICMDAddrSpaceL2TCM,
      AICMDMulticastEntryAddrSpace_AICMDAddrSpaceVTCM};
  return values;
}

inline const char *const *EnumNamesAICMDMulticastEntryAddrSpace() {
  static const char *const names[3] = {"AICMDAddrSpaceL2TCM",
                                       "AICMDAddrSpaceVTCM", nullptr};
  return names;
}

inline const char *
EnumNameAICMDMulticastEntryAddrSpace(AICMDMulticastEntryAddrSpace e) {
  if (flatbuffers::IsOutRange(e,
                              AICMDMulticastEntryAddrSpace_AICMDAddrSpaceL2TCM,
                              AICMDMulticastEntryAddrSpace_AICMDAddrSpaceVTCM))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDMulticastEntryAddrSpace()[index];
}

enum AICMDThreadType : int8_t {
  AICMDThreadType_AICMDThreadHMX = 1,
  AICMDThreadType_AICMDThreadHVX = 2,
  AICMDThreadType_MIN = AICMDThreadType_AICMDThreadHMX,
  AICMDThreadType_MAX = AICMDThreadType_AICMDThreadHVX
};

inline const AICMDThreadType (&EnumValuesAICMDThreadType())[2] {
  static const AICMDThreadType values[] = {AICMDThreadType_AICMDThreadHMX,
                                           AICMDThreadType_AICMDThreadHVX};
  return values;
}

inline const char *const *EnumNamesAICMDThreadType() {
  static const char *const names[3] = {"AICMDThreadHMX", "AICMDThreadHVX",
                                       nullptr};
  return names;
}

inline const char *EnumNameAICMDThreadType(AICMDThreadType e) {
  if (flatbuffers::IsOutRange(e, AICMDThreadType_AICMDThreadHMX,
                              AICMDThreadType_AICMDThreadHVX))
    return "";
  const size_t index = static_cast<size_t>(e) -
                       static_cast<size_t>(AICMDThreadType_AICMDThreadHMX);
  return EnumNamesAICMDThreadType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8)
execContextField FLATBUFFERS_FINAL_CLASS {
private:
  int8_t variableNeeded_;
  int8_t padding0__;
  uint16_t variableSize_;
  int32_t padding1__;
  uint64_t execContextOffset_;
  uint8_t isRequired_;
  int8_t padding2__;
  int16_t padding3__;
  int32_t padding4__;

public:
  execContextField()
      : variableNeeded_(0), padding0__(0), variableSize_(0), padding1__(0),
        execContextOffset_(0), isRequired_(0), padding2__(0), padding3__(0),
        padding4__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
    (void)padding4__;
  }
  execContextField(AicMetadataFlat::execContextVariables _variableNeeded,
                   uint16_t _variableSize, uint64_t _execContextOffset,
                   bool _isRequired)
      : variableNeeded_(
            flatbuffers::EndianScalar(static_cast<int8_t>(_variableNeeded))),
        padding0__(0), variableSize_(flatbuffers::EndianScalar(_variableSize)),
        padding1__(0),
        execContextOffset_(flatbuffers::EndianScalar(_execContextOffset)),
        isRequired_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_isRequired))),
        padding2__(0), padding3__(0), padding4__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
    (void)padding4__;
  }
  AicMetadataFlat::execContextVariables variableNeeded() const {
    return static_cast<AicMetadataFlat::execContextVariables>(
        flatbuffers::EndianScalar(variableNeeded_));
  }
  uint16_t variableSize() const {
    return flatbuffers::EndianScalar(variableSize_);
  }
  uint64_t execContextOffset() const {
    return flatbuffers::EndianScalar(execContextOffset_);
  }
  bool isRequired() const {
    return flatbuffers::EndianScalar(isRequired_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(execContextField, 24);

struct execContextT : public flatbuffers::NativeTable {
  typedef execContext TableType;
  uint16_t execContextSize = 0;
  std::vector<AicMetadataFlat::execContextField> execContextFields{};
};

struct execContext FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef execContextT NativeTableType;
  typedef execContextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXECCONTEXTSIZE = 4,
    VT_EXECCONTEXTFIELDS = 6
  };
  uint16_t execContextSize() const {
    return GetField<uint16_t>(VT_EXECCONTEXTSIZE, 0);
  }
  const flatbuffers::Vector<const AicMetadataFlat::execContextField *> *
  execContextFields() const {
    return GetPointer<
        const flatbuffers::Vector<const AicMetadataFlat::execContextField *> *>(
        VT_EXECCONTEXTFIELDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_EXECCONTEXTSIZE, 2) &&
           VerifyOffset(verifier, VT_EXECCONTEXTFIELDS) &&
           verifier.VerifyVector(execContextFields()) && verifier.EndTable();
  }
  execContextT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void
  UnPackTo(execContextT *_o,
           const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<execContext>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const execContextT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct execContextBuilder {
  typedef execContext Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_execContextSize(uint16_t execContextSize) {
    fbb_.AddElement<uint16_t>(execContext::VT_EXECCONTEXTSIZE, execContextSize,
                              0);
  }
  void add_execContextFields(
      flatbuffers::Offset<
          flatbuffers::Vector<const AicMetadataFlat::execContextField *>>
          execContextFields) {
    fbb_.AddOffset(execContext::VT_EXECCONTEXTFIELDS, execContextFields);
  }
  explicit execContextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<execContext> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<execContext>(end);
    return o;
  }
};

inline flatbuffers::Offset<execContext> CreateexecContext(
    flatbuffers::FlatBufferBuilder &_fbb, uint16_t execContextSize = 0,
    flatbuffers::Offset<
        flatbuffers::Vector<const AicMetadataFlat::execContextField *>>
        execContextFields = 0) {
  execContextBuilder builder_(_fbb);
  builder_.add_execContextFields(execContextFields);
  builder_.add_execContextSize(execContextSize);
  return builder_.Finish();
}

inline flatbuffers::Offset<execContext> CreateexecContextDirect(
    flatbuffers::FlatBufferBuilder &_fbb, uint16_t execContextSize = 0,
    const std::vector<AicMetadataFlat::execContextField> *execContextFields =
        nullptr) {
  auto execContextFields__ =
      execContextFields
          ? _fbb.CreateVectorOfStructs<AicMetadataFlat::execContextField>(
                *execContextFields)
          : 0;
  return AicMetadataFlat::CreateexecContext(_fbb, execContextSize,
                                            execContextFields__);
}

flatbuffers::Offset<execContext>
CreateexecContext(flatbuffers::FlatBufferBuilder &_fbb, const execContextT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDSemaphoreOpT : public flatbuffers::NativeTable {
  typedef AICMDSemaphoreOp TableType;
  uint16_t semNum = 0;
  uint16_t semValue = 0;
  uint8_t semOp = 0;
  uint8_t preOrPost = 0;
  uint8_t inSyncFence = 0;
  uint8_t outSyncFence = 0;
};

struct AICMDSemaphoreOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDSemaphoreOpT NativeTableType;
  typedef AICMDSemaphoreOpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEMNUM = 4,
    VT_SEMVALUE = 6,
    VT_SEMOP = 8,
    VT_PREORPOST = 10,
    VT_INSYNCFENCE = 12,
    VT_OUTSYNCFENCE = 14
  };
  uint16_t semNum() const { return GetField<uint16_t>(VT_SEMNUM, 0); }
  uint16_t semValue() const { return GetField<uint16_t>(VT_SEMVALUE, 0); }
  uint8_t semOp() const { return GetField<uint8_t>(VT_SEMOP, 0); }
  uint8_t preOrPost() const { return GetField<uint8_t>(VT_PREORPOST, 0); }
  uint8_t inSyncFence() const { return GetField<uint8_t>(VT_INSYNCFENCE, 0); }
  uint8_t outSyncFence() const { return GetField<uint8_t>(VT_OUTSYNCFENCE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SEMNUM, 2) &&
           VerifyField<uint16_t>(verifier, VT_SEMVALUE, 2) &&
           VerifyField<uint8_t>(verifier, VT_SEMOP, 1) &&
           VerifyField<uint8_t>(verifier, VT_PREORPOST, 1) &&
           VerifyField<uint8_t>(verifier, VT_INSYNCFENCE, 1) &&
           VerifyField<uint8_t>(verifier, VT_OUTSYNCFENCE, 1) &&
           verifier.EndTable();
  }
  AICMDSemaphoreOpT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void
  UnPackTo(AICMDSemaphoreOpT *_o,
           const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDSemaphoreOp>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDSemaphoreOpT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDSemaphoreOpBuilder {
  typedef AICMDSemaphoreOp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_semNum(uint16_t semNum) {
    fbb_.AddElement<uint16_t>(AICMDSemaphoreOp::VT_SEMNUM, semNum, 0);
  }
  void add_semValue(uint16_t semValue) {
    fbb_.AddElement<uint16_t>(AICMDSemaphoreOp::VT_SEMVALUE, semValue, 0);
  }
  void add_semOp(uint8_t semOp) {
    fbb_.AddElement<uint8_t>(AICMDSemaphoreOp::VT_SEMOP, semOp, 0);
  }
  void add_preOrPost(uint8_t preOrPost) {
    fbb_.AddElement<uint8_t>(AICMDSemaphoreOp::VT_PREORPOST, preOrPost, 0);
  }
  void add_inSyncFence(uint8_t inSyncFence) {
    fbb_.AddElement<uint8_t>(AICMDSemaphoreOp::VT_INSYNCFENCE, inSyncFence, 0);
  }
  void add_outSyncFence(uint8_t outSyncFence) {
    fbb_.AddElement<uint8_t>(AICMDSemaphoreOp::VT_OUTSYNCFENCE, outSyncFence,
                             0);
  }
  explicit AICMDSemaphoreOpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDSemaphoreOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDSemaphoreOp>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDSemaphoreOp>
CreateAICMDSemaphoreOp(flatbuffers::FlatBufferBuilder &_fbb,
                       uint16_t semNum = 0, uint16_t semValue = 0,
                       uint8_t semOp = 0, uint8_t preOrPost = 0,
                       uint8_t inSyncFence = 0, uint8_t outSyncFence = 0) {
  AICMDSemaphoreOpBuilder builder_(_fbb);
  builder_.add_semValue(semValue);
  builder_.add_semNum(semNum);
  builder_.add_outSyncFence(outSyncFence);
  builder_.add_inSyncFence(inSyncFence);
  builder_.add_preOrPost(preOrPost);
  builder_.add_semOp(semOp);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDSemaphoreOp> CreateAICMDSemaphoreOp(
    flatbuffers::FlatBufferBuilder &_fbb, const AICMDSemaphoreOpT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDDoorbellOpT : public flatbuffers::NativeTable {
  typedef AICMDDoorbellOp TableType;
  uint64_t offset = 0;
  uint32_t data = 0;
  uint16_t mcId = 0;
  uint8_t size = 0;
};

struct AICMDDoorbellOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDDoorbellOpT NativeTableType;
  typedef AICMDDoorbellOpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_DATA = 6,
    VT_MCID = 8,
    VT_SIZE = 10
  };
  uint64_t offset() const { return GetField<uint64_t>(VT_OFFSET, 0); }
  uint32_t data() const { return GetField<uint32_t>(VT_DATA, 0); }
  uint16_t mcId() const { return GetField<uint16_t>(VT_MCID, 0); }
  uint8_t size() const { return GetField<uint8_t>(VT_SIZE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_DATA, 4) &&
           VerifyField<uint16_t>(verifier, VT_MCID, 2) &&
           VerifyField<uint8_t>(verifier, VT_SIZE, 1) && verifier.EndTable();
  }
  AICMDDoorbellOpT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void
  UnPackTo(AICMDDoorbellOpT *_o,
           const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDDoorbellOp>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDDoorbellOpT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDDoorbellOpBuilder {
  typedef AICMDDoorbellOp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(AICMDDoorbellOp::VT_OFFSET, offset, 0);
  }
  void add_data(uint32_t data) {
    fbb_.AddElement<uint32_t>(AICMDDoorbellOp::VT_DATA, data, 0);
  }
  void add_mcId(uint16_t mcId) {
    fbb_.AddElement<uint16_t>(AICMDDoorbellOp::VT_MCID, mcId, 0);
  }
  void add_size(uint8_t size) {
    fbb_.AddElement<uint8_t>(AICMDDoorbellOp::VT_SIZE, size, 0);
  }
  explicit AICMDDoorbellOpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDDoorbellOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDDoorbellOp>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDDoorbellOp>
CreateAICMDDoorbellOp(flatbuffers::FlatBufferBuilder &_fbb, uint64_t offset = 0,
                      uint32_t data = 0, uint16_t mcId = 0, uint8_t size = 0) {
  AICMDDoorbellOpBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_data(data);
  builder_.add_mcId(mcId);
  builder_.add_size(size);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDDoorbellOp> CreateAICMDDoorbellOp(
    flatbuffers::FlatBufferBuilder &_fbb, const AICMDDoorbellOpT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDDMARequestT : public flatbuffers::NativeTable {
  typedef AICMDDMARequest TableType;
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDSemaphoreOpT>>
      semaphoreOps{};
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDDoorbellOpT>> doorbellOps{};
  uint64_t hostOffset = 0;
  uint64_t devOffset = 0;
  uint32_t size = 0;
  uint16_t num = 0;
  uint16_t mcId = 0;
  uint8_t devAddrSpace = 0;
  uint8_t inOut = 0;
  uint16_t portId = 0;
  AICMDDMARequestT() = default;
  AICMDDMARequestT(const AICMDDMARequestT &o);
  AICMDDMARequestT(AICMDDMARequestT &&) FLATBUFFERS_NOEXCEPT = default;
  AICMDDMARequestT &operator=(AICMDDMARequestT o) FLATBUFFERS_NOEXCEPT;
};

struct AICMDDMARequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDDMARequestT NativeTableType;
  typedef AICMDDMARequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEMAPHOREOPS = 4,
    VT_DOORBELLOPS = 6,
    VT_HOSTOFFSET = 8,
    VT_DEVOFFSET = 10,
    VT_SIZE = 12,
    VT_NUM = 14,
    VT_MCID = 16,
    VT_DEVADDRSPACE = 18,
    VT_INOUT = 20,
    VT_PORTID = 22
  };
  const flatbuffers::Vector<
      flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>> *
  semaphoreOps() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>> *>(
        VT_SEMAPHOREOPS);
  }
  const flatbuffers::Vector<
      flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>> *
  doorbellOps() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>> *>(
        VT_DOORBELLOPS);
  }
  uint64_t hostOffset() const { return GetField<uint64_t>(VT_HOSTOFFSET, 0); }
  uint64_t devOffset() const { return GetField<uint64_t>(VT_DEVOFFSET, 0); }
  uint32_t size() const { return GetField<uint32_t>(VT_SIZE, 0); }
  uint16_t num() const { return GetField<uint16_t>(VT_NUM, 0); }
  uint16_t mcId() const { return GetField<uint16_t>(VT_MCID, 0); }
  uint8_t devAddrSpace() const { return GetField<uint8_t>(VT_DEVADDRSPACE, 0); }
  uint8_t inOut() const { return GetField<uint8_t>(VT_INOUT, 0); }
  uint16_t portId() const { return GetField<uint16_t>(VT_PORTID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SEMAPHOREOPS) &&
           verifier.VerifyVector(semaphoreOps()) &&
           verifier.VerifyVectorOfTables(semaphoreOps()) &&
           VerifyOffset(verifier, VT_DOORBELLOPS) &&
           verifier.VerifyVector(doorbellOps()) &&
           verifier.VerifyVectorOfTables(doorbellOps()) &&
           VerifyField<uint64_t>(verifier, VT_HOSTOFFSET, 8) &&
           VerifyField<uint64_t>(verifier, VT_DEVOFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint16_t>(verifier, VT_NUM, 2) &&
           VerifyField<uint16_t>(verifier, VT_MCID, 2) &&
           VerifyField<uint8_t>(verifier, VT_DEVADDRSPACE, 1) &&
           VerifyField<uint8_t>(verifier, VT_INOUT, 1) &&
           VerifyField<uint16_t>(verifier, VT_PORTID, 2) && verifier.EndTable();
  }
  AICMDDMARequestT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void
  UnPackTo(AICMDDMARequestT *_o,
           const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDDMARequest>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDDMARequestT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDDMARequestBuilder {
  typedef AICMDDMARequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void
  add_semaphoreOps(flatbuffers::Offset<flatbuffers::Vector<
                       flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>>>
                       semaphoreOps) {
    fbb_.AddOffset(AICMDDMARequest::VT_SEMAPHOREOPS, semaphoreOps);
  }
  void
  add_doorbellOps(flatbuffers::Offset<flatbuffers::Vector<
                      flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>>>
                      doorbellOps) {
    fbb_.AddOffset(AICMDDMARequest::VT_DOORBELLOPS, doorbellOps);
  }
  void add_hostOffset(uint64_t hostOffset) {
    fbb_.AddElement<uint64_t>(AICMDDMARequest::VT_HOSTOFFSET, hostOffset, 0);
  }
  void add_devOffset(uint64_t devOffset) {
    fbb_.AddElement<uint64_t>(AICMDDMARequest::VT_DEVOFFSET, devOffset, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(AICMDDMARequest::VT_SIZE, size, 0);
  }
  void add_num(uint16_t num) {
    fbb_.AddElement<uint16_t>(AICMDDMARequest::VT_NUM, num, 0);
  }
  void add_mcId(uint16_t mcId) {
    fbb_.AddElement<uint16_t>(AICMDDMARequest::VT_MCID, mcId, 0);
  }
  void add_devAddrSpace(uint8_t devAddrSpace) {
    fbb_.AddElement<uint8_t>(AICMDDMARequest::VT_DEVADDRSPACE, devAddrSpace, 0);
  }
  void add_inOut(uint8_t inOut) {
    fbb_.AddElement<uint8_t>(AICMDDMARequest::VT_INOUT, inOut, 0);
  }
  void add_portId(uint16_t portId) {
    fbb_.AddElement<uint16_t>(AICMDDMARequest::VT_PORTID, portId, 0);
  }
  explicit AICMDDMARequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDDMARequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDDMARequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDDMARequest> CreateAICMDDMARequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>>>
        semaphoreOps = 0,
    flatbuffers::Offset<flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>>>
        doorbellOps = 0,
    uint64_t hostOffset = 0, uint64_t devOffset = 0, uint32_t size = 0,
    uint16_t num = 0, uint16_t mcId = 0, uint8_t devAddrSpace = 0,
    uint8_t inOut = 0, uint16_t portId = 0) {
  AICMDDMARequestBuilder builder_(_fbb);
  builder_.add_devOffset(devOffset);
  builder_.add_hostOffset(hostOffset);
  builder_.add_size(size);
  builder_.add_doorbellOps(doorbellOps);
  builder_.add_semaphoreOps(semaphoreOps);
  builder_.add_portId(portId);
  builder_.add_mcId(mcId);
  builder_.add_num(num);
  builder_.add_inOut(inOut);
  builder_.add_devAddrSpace(devAddrSpace);
  return builder_.Finish();
}

inline flatbuffers::Offset<AICMDDMARequest> CreateAICMDDMARequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>>
        *semaphoreOps = nullptr,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>>
        *doorbellOps = nullptr,
    uint64_t hostOffset = 0, uint64_t devOffset = 0, uint32_t size = 0,
    uint16_t num = 0, uint16_t mcId = 0, uint8_t devAddrSpace = 0,
    uint8_t inOut = 0, uint16_t portId = 0) {
  auto semaphoreOps__ =
      semaphoreOps
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>>(
                *semaphoreOps)
          : 0;
  auto doorbellOps__ =
      doorbellOps
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>>(
                *doorbellOps)
          : 0;
  return AicMetadataFlat::CreateAICMDDMARequest(
      _fbb, semaphoreOps__, doorbellOps__, hostOffset, devOffset, size, num,
      mcId, devAddrSpace, inOut, portId);
}

flatbuffers::Offset<AICMDDMARequest> CreateAICMDDMARequest(
    flatbuffers::FlatBufferBuilder &_fbb, const AICMDDMARequestT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDNSPMulticastEntryT : public flatbuffers::NativeTable {
  typedef AICMDNSPMulticastEntry TableType;
  uint64_t baseAddrOffset = 0;
  uint32_t mask = 0;
  uint32_t size = 0;
  uint8_t addrSpace = 0;
  uint8_t dynamic = 0;
};

struct AICMDNSPMulticastEntry FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  typedef AICMDNSPMulticastEntryT NativeTableType;
  typedef AICMDNSPMulticastEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASEADDROFFSET = 4,
    VT_MASK = 6,
    VT_SIZE = 8,
    VT_ADDRSPACE = 10,
    VT_DYNAMIC = 12
  };
  uint64_t baseAddrOffset() const {
    return GetField<uint64_t>(VT_BASEADDROFFSET, 0);
  }
  uint32_t mask() const { return GetField<uint32_t>(VT_MASK, 0); }
  uint32_t size() const { return GetField<uint32_t>(VT_SIZE, 0); }
  uint8_t addrSpace() const { return GetField<uint8_t>(VT_ADDRSPACE, 0); }
  uint8_t dynamic() const { return GetField<uint8_t>(VT_DYNAMIC, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_BASEADDROFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_MASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ADDRSPACE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMIC, 1) && verifier.EndTable();
  }
  AICMDNSPMulticastEntryT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void
  UnPackTo(AICMDNSPMulticastEntryT *_o,
           const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDNSPMulticastEntry>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDNSPMulticastEntryBuilder {
  typedef AICMDNSPMulticastEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_baseAddrOffset(uint64_t baseAddrOffset) {
    fbb_.AddElement<uint64_t>(AICMDNSPMulticastEntry::VT_BASEADDROFFSET,
                              baseAddrOffset, 0);
  }
  void add_mask(uint32_t mask) {
    fbb_.AddElement<uint32_t>(AICMDNSPMulticastEntry::VT_MASK, mask, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(AICMDNSPMulticastEntry::VT_SIZE, size, 0);
  }
  void add_addrSpace(uint8_t addrSpace) {
    fbb_.AddElement<uint8_t>(AICMDNSPMulticastEntry::VT_ADDRSPACE, addrSpace,
                             0);
  }
  void add_dynamic(uint8_t dynamic) {
    fbb_.AddElement<uint8_t>(AICMDNSPMulticastEntry::VT_DYNAMIC, dynamic, 0);
  }
  explicit AICMDNSPMulticastEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDNSPMulticastEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDNSPMulticastEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDNSPMulticastEntry>
CreateAICMDNSPMulticastEntry(flatbuffers::FlatBufferBuilder &_fbb,
                             uint64_t baseAddrOffset = 0, uint32_t mask = 0,
                             uint32_t size = 0, uint8_t addrSpace = 0,
                             uint8_t dynamic = 0) {
  AICMDNSPMulticastEntryBuilder builder_(_fbb);
  builder_.add_baseAddrOffset(baseAddrOffset);
  builder_.add_size(size);
  builder_.add_mask(mask);
  builder_.add_dynamic(dynamic);
  builder_.add_addrSpace(addrSpace);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDNSPMulticastEntry> CreateAICMDNSPMulticastEntry(
    flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDNSPMulticastEntryTableT : public flatbuffers::NativeTable {
  typedef AICMDNSPMulticastEntryTable TableType;
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDNSPMulticastEntryT>>
      multicastEntries{};
  AICMDNSPMulticastEntryTableT() = default;
  AICMDNSPMulticastEntryTableT(const AICMDNSPMulticastEntryTableT &o);
  AICMDNSPMulticastEntryTableT(AICMDNSPMulticastEntryTableT &&)
      FLATBUFFERS_NOEXCEPT = default;
  AICMDNSPMulticastEntryTableT &
  operator=(AICMDNSPMulticastEntryTableT o) FLATBUFFERS_NOEXCEPT;
};

struct AICMDNSPMulticastEntryTable FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  typedef AICMDNSPMulticastEntryTableT NativeTableType;
  typedef AICMDNSPMulticastEntryTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MULTICASTENTRIES = 4
  };
  const flatbuffers::Vector<
      flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>> *
  multicastEntries() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>> *>(
        VT_MULTICASTENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MULTICASTENTRIES) &&
           verifier.VerifyVector(multicastEntries()) &&
           verifier.VerifyVectorOfTables(multicastEntries()) &&
           verifier.EndTable();
  }
  AICMDNSPMulticastEntryTableT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void
  UnPackTo(AICMDNSPMulticastEntryTableT *_o,
           const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDNSPMulticastEntryTable>
  Pack(flatbuffers::FlatBufferBuilder &_fbb,
       const AICMDNSPMulticastEntryTableT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDNSPMulticastEntryTableBuilder {
  typedef AICMDNSPMulticastEntryTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_multicastEntries(
      flatbuffers::Offset<flatbuffers::Vector<
          flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>>>
          multicastEntries) {
    fbb_.AddOffset(AICMDNSPMulticastEntryTable::VT_MULTICASTENTRIES,
                   multicastEntries);
  }
  explicit AICMDNSPMulticastEntryTableBuilder(
      flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDNSPMulticastEntryTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDNSPMulticastEntryTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDNSPMulticastEntryTable>
CreateAICMDNSPMulticastEntryTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>>>
        multicastEntries = 0) {
  AICMDNSPMulticastEntryTableBuilder builder_(_fbb);
  builder_.add_multicastEntries(multicastEntries);
  return builder_.Finish();
}

inline flatbuffers::Offset<AICMDNSPMulticastEntryTable>
CreateAICMDNSPMulticastEntryTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<
        AicMetadataFlat::AICMDNSPMulticastEntry>> *multicastEntries = nullptr) {
  auto multicastEntries__ =
      multicastEntries
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>>(
                *multicastEntries)
          : 0;
  return AicMetadataFlat::CreateAICMDNSPMulticastEntryTable(_fbb,
                                                            multicastEntries__);
}

flatbuffers::Offset<AICMDNSPMulticastEntryTable>
CreateAICMDNSPMulticastEntryTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    const AICMDNSPMulticastEntryTableT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDHostMulticastEntryT : public flatbuffers::NativeTable {
  typedef AICMDHostMulticastEntry TableType;
  uint32_t mask = 0;
  uint32_t size = 0;
};

struct AICMDHostMulticastEntry FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  typedef AICMDHostMulticastEntryT NativeTableType;
  typedef AICMDHostMulticastEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MASK = 4,
    VT_SIZE = 6
  };
  uint32_t mask() const { return GetField<uint32_t>(VT_MASK, 0); }
  uint32_t size() const { return GetField<uint32_t>(VT_SIZE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) && verifier.EndTable();
  }
  AICMDHostMulticastEntryT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void
  UnPackTo(AICMDHostMulticastEntryT *_o,
           const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDHostMulticastEntry>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDHostMulticastEntryBuilder {
  typedef AICMDHostMulticastEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mask(uint32_t mask) {
    fbb_.AddElement<uint32_t>(AICMDHostMulticastEntry::VT_MASK, mask, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(AICMDHostMulticastEntry::VT_SIZE, size, 0);
  }
  explicit AICMDHostMulticastEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDHostMulticastEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDHostMulticastEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDHostMulticastEntry>
CreateAICMDHostMulticastEntry(flatbuffers::FlatBufferBuilder &_fbb,
                              uint32_t mask = 0, uint32_t size = 0) {
  AICMDHostMulticastEntryBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_mask(mask);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDHostMulticastEntry> CreateAICMDHostMulticastEntry(
    flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDHostMulticastEntryTableT : public flatbuffers::NativeTable {
  typedef AICMDHostMulticastEntryTable TableType;
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDHostMulticastEntryT>>
      multicastEntries{};
  AICMDHostMulticastEntryTableT() = default;
  AICMDHostMulticastEntryTableT(const AICMDHostMulticastEntryTableT &o);
  AICMDHostMulticastEntryTableT(AICMDHostMulticastEntryTableT &&)
      FLATBUFFERS_NOEXCEPT = default;
  AICMDHostMulticastEntryTableT &
  operator=(AICMDHostMulticastEntryTableT o) FLATBUFFERS_NOEXCEPT;
};

struct AICMDHostMulticastEntryTable FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  typedef AICMDHostMulticastEntryTableT NativeTableType;
  typedef AICMDHostMulticastEntryTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MULTICASTENTRIES = 4
  };
  const flatbuffers::Vector<
      flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>> *
  multicastEntries() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>> *>(
        VT_MULTICASTENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MULTICASTENTRIES) &&
           verifier.VerifyVector(multicastEntries()) &&
           verifier.VerifyVectorOfTables(multicastEntries()) &&
           verifier.EndTable();
  }
  AICMDHostMulticastEntryTableT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void
  UnPackTo(AICMDHostMulticastEntryTableT *_o,
           const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDHostMulticastEntryTable>
  Pack(flatbuffers::FlatBufferBuilder &_fbb,
       const AICMDHostMulticastEntryTableT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDHostMulticastEntryTableBuilder {
  typedef AICMDHostMulticastEntryTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_multicastEntries(
      flatbuffers::Offset<flatbuffers::Vector<
          flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>>>
          multicastEntries) {
    fbb_.AddOffset(AICMDHostMulticastEntryTable::VT_MULTICASTENTRIES,
                   multicastEntries);
  }
  explicit AICMDHostMulticastEntryTableBuilder(
      flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDHostMulticastEntryTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDHostMulticastEntryTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDHostMulticastEntryTable>
CreateAICMDHostMulticastEntryTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>>>
        multicastEntries = 0) {
  AICMDHostMulticastEntryTableBuilder builder_(_fbb);
  builder_.add_multicastEntries(multicastEntries);
  return builder_.Finish();
}

inline flatbuffers::Offset<AICMDHostMulticastEntryTable>
CreateAICMDHostMulticastEntryTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>>
        *multicastEntries = nullptr) {
  auto multicastEntries__ =
      multicastEntries
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>>(
                *multicastEntries)
          : 0;
  return AicMetadataFlat::CreateAICMDHostMulticastEntryTable(
      _fbb, multicastEntries__);
}

flatbuffers::Offset<AICMDHostMulticastEntryTable>
CreateAICMDHostMulticastEntryTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    const AICMDHostMulticastEntryTableT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDThreadDescriptorT : public flatbuffers::NativeTable {
  typedef AICMDThreadDescriptor TableType;
  uint64_t entryPoint = 0;
  uint8_t typeMask = 0;
};

struct AICMDThreadDescriptor FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  typedef AICMDThreadDescriptorT NativeTableType;
  typedef AICMDThreadDescriptorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRYPOINT = 4,
    VT_TYPEMASK = 6
  };
  uint64_t entryPoint() const { return GetField<uint64_t>(VT_ENTRYPOINT, 0); }
  uint8_t typeMask() const { return GetField<uint8_t>(VT_TYPEMASK, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ENTRYPOINT, 8) &&
           VerifyField<uint8_t>(verifier, VT_TYPEMASK, 1) &&
           verifier.EndTable();
  }
  AICMDThreadDescriptorT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void
  UnPackTo(AICMDThreadDescriptorT *_o,
           const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDThreadDescriptor>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDThreadDescriptorT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDThreadDescriptorBuilder {
  typedef AICMDThreadDescriptor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entryPoint(uint64_t entryPoint) {
    fbb_.AddElement<uint64_t>(AICMDThreadDescriptor::VT_ENTRYPOINT, entryPoint,
                              0);
  }
  void add_typeMask(uint8_t typeMask) {
    fbb_.AddElement<uint8_t>(AICMDThreadDescriptor::VT_TYPEMASK, typeMask, 0);
  }
  explicit AICMDThreadDescriptorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDThreadDescriptor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDThreadDescriptor>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDThreadDescriptor>
CreateAICMDThreadDescriptor(flatbuffers::FlatBufferBuilder &_fbb,
                            uint64_t entryPoint = 0, uint8_t typeMask = 0) {
  AICMDThreadDescriptorBuilder builder_(_fbb);
  builder_.add_entryPoint(entryPoint);
  builder_.add_typeMask(typeMask);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDThreadDescriptor> CreateAICMDThreadDescriptor(
    flatbuffers::FlatBufferBuilder &_fbb, const AICMDThreadDescriptorT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDConstantMappingT : public flatbuffers::NativeTable {
  typedef AICMDConstantMapping TableType;
  uint64_t constantDataBaseOffset = 0;
  uint32_t coreMask = 0;
  uint32_t size = 0;
};

struct AICMDConstantMapping FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  typedef AICMDConstantMappingT NativeTableType;
  typedef AICMDConstantMappingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTANTDATABASEOFFSET = 4,
    VT_COREMASK = 6,
    VT_SIZE = 8
  };
  uint64_t constantDataBaseOffset() const {
    return GetField<uint64_t>(VT_CONSTANTDATABASEOFFSET, 0);
  }
  uint32_t coreMask() const { return GetField<uint32_t>(VT_COREMASK, 0); }
  uint32_t size() const { return GetField<uint32_t>(VT_SIZE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CONSTANTDATABASEOFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_COREMASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) && verifier.EndTable();
  }
  AICMDConstantMappingT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void
  UnPackTo(AICMDConstantMappingT *_o,
           const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDConstantMapping>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDConstantMappingT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDConstantMappingBuilder {
  typedef AICMDConstantMapping Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_constantDataBaseOffset(uint64_t constantDataBaseOffset) {
    fbb_.AddElement<uint64_t>(AICMDConstantMapping::VT_CONSTANTDATABASEOFFSET,
                              constantDataBaseOffset, 0);
  }
  void add_coreMask(uint32_t coreMask) {
    fbb_.AddElement<uint32_t>(AICMDConstantMapping::VT_COREMASK, coreMask, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(AICMDConstantMapping::VT_SIZE, size, 0);
  }
  explicit AICMDConstantMappingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDConstantMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDConstantMapping>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDConstantMapping>
CreateAICMDConstantMapping(flatbuffers::FlatBufferBuilder &_fbb,
                           uint64_t constantDataBaseOffset = 0,
                           uint32_t coreMask = 0, uint32_t size = 0) {
  AICMDConstantMappingBuilder builder_(_fbb);
  builder_.add_constantDataBaseOffset(constantDataBaseOffset);
  builder_.add_size(size);
  builder_.add_coreMask(coreMask);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDConstantMapping> CreateAICMDConstantMapping(
    flatbuffers::FlatBufferBuilder &_fbb, const AICMDConstantMappingT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MetadataT : public flatbuffers::NativeTable {
  typedef Metadata TableType;
  uint16_t versionMajor = 0;
  uint16_t versionMinor = 0;
  std::string networkName{};
  std::vector<std::string> requiredFields{};
  std::vector<uint32_t> semaphoreInitState{};
  std::vector<uint8_t> L2TCMInitState{};
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDDMARequestT>> dmaRequests{};
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDNSPMulticastEntryTableT>>
      nspMulticastTables{};
  std::unique_ptr<AicMetadataFlat::AICMDHostMulticastEntryTableT>
      hostMulticastTable{};
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDThreadDescriptorT>>
      threadDescriptors{};
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDConstantMappingT>>
      constantMappings{};
  uint64_t staticSharedDDRSize = 0;
  uint64_t dynamicSharedDDRSize = 0;
  uint64_t staticConstantsSize = 0;
  uint64_t dynamicConstantsSize = 0;
  uint64_t exitDoorbellOffset = 0;
  uint32_t l2CachedDDRSize = 0;
  uint32_t L2TCMInitSize = 0;
  uint16_t execContextMajorVersion = 0;
  uint16_t numNSPs = 0;
  uint16_t numSemaphores = 0;
  uint8_t hwVersionMajor = 0;
  uint8_t hwVersionMinor = 0;
  uint8_t staticSharedDDRECCEnabled = 0;
  uint8_t dynamicSharedDDRECCEnabled = 0;
  uint8_t staticConstantsECCEnabled = 0;
  uint8_t dynamicConstantsECCEnabled = 0;
  uint8_t singleVTCMPage = 0;
  uint8_t hasHvxFP = 0;
  uint8_t hasHmxFP = 0;
  uint32_t VTCMSize = 0;
  uint32_t L2TCMSize = 0;
  uint64_t networkHeapSize = 0;
  uint64_t raw_struct_version_length = 0;
  MetadataT() = default;
  MetadataT(const MetadataT &o);
  MetadataT(MetadataT &&) FLATBUFFERS_NOEXCEPT = default;
  MetadataT &operator=(MetadataT o) FLATBUFFERS_NOEXCEPT;
};

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetadataT NativeTableType;
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSIONMAJOR = 4,
    VT_VERSIONMINOR = 6,
    VT_NETWORKNAME = 8,
    VT_REQUIREDFIELDS = 10,
    VT_SEMAPHOREINITSTATE = 12,
    VT_L2TCMINITSTATE = 14,
    VT_DMAREQUESTS = 16,
    VT_NSPMULTICASTTABLES = 18,
    VT_HOSTMULTICASTTABLE = 20,
    VT_THREADDESCRIPTORS = 22,
    VT_CONSTANTMAPPINGS = 24,
    VT_STATICSHAREDDDRSIZE = 26,
    VT_DYNAMICSHAREDDDRSIZE = 28,
    VT_STATICCONSTANTSSIZE = 30,
    VT_DYNAMICCONSTANTSSIZE = 32,
    VT_EXITDOORBELLOFFSET = 34,
    VT_L2CACHEDDDRSIZE = 36,
    VT_L2TCMINITSIZE = 38,
    VT_EXECCONTEXTMAJORVERSION = 40,
    VT_NUMNSPS = 42,
    VT_NUMSEMAPHORES = 44,
    VT_HWVERSIONMAJOR = 46,
    VT_HWVERSIONMINOR = 48,
    VT_STATICSHAREDDDRECCENABLED = 50,
    VT_DYNAMICSHAREDDDRECCENABLED = 52,
    VT_STATICCONSTANTSECCENABLED = 54,
    VT_DYNAMICCONSTANTSECCENABLED = 56,
    VT_SINGLEVTCMPAGE = 58,
    VT_HASHVXFP = 60,
    VT_HASHMXFP = 62,
    VT_VTCMSIZE = 64,
    VT_L2TCMSIZE = 66,
    VT_NETWORKHEAPSIZE = 68,
    VT_RAW_STRUCT_VERSION_LENGTH = 70
  };
  uint16_t versionMajor() const {
    return GetField<uint16_t>(VT_VERSIONMAJOR, 0);
  }
  uint16_t versionMinor() const {
    return GetField<uint16_t>(VT_VERSIONMINOR, 0);
  }
  const flatbuffers::String *networkName() const {
    return GetPointer<const flatbuffers::String *>(VT_NETWORKNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *
  requiredFields() const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(
        VT_REQUIREDFIELDS);
  }
  const flatbuffers::Vector<uint32_t> *semaphoreInitState() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(
        VT_SEMAPHOREINITSTATE);
  }
  const flatbuffers::Vector<uint8_t> *L2TCMInitState() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_L2TCMINITSTATE);
  }
  const flatbuffers::Vector<
      flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>> *
  dmaRequests() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>> *>(
        VT_DMAREQUESTS);
  }
  const flatbuffers::Vector<
      flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>> *
  nspMulticastTables() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>> *>(
        VT_NSPMULTICASTTABLES);
  }
  const AicMetadataFlat::AICMDHostMulticastEntryTable *
  hostMulticastTable() const {
    return GetPointer<const AicMetadataFlat::AICMDHostMulticastEntryTable *>(
        VT_HOSTMULTICASTTABLE);
  }
  const flatbuffers::Vector<
      flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>> *
  threadDescriptors() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>> *>(
        VT_THREADDESCRIPTORS);
  }
  const flatbuffers::Vector<
      flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>> *
  constantMappings() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>> *>(
        VT_CONSTANTMAPPINGS);
  }
  uint64_t staticSharedDDRSize() const {
    return GetField<uint64_t>(VT_STATICSHAREDDDRSIZE, 0);
  }
  uint64_t dynamicSharedDDRSize() const {
    return GetField<uint64_t>(VT_DYNAMICSHAREDDDRSIZE, 0);
  }
  uint64_t staticConstantsSize() const {
    return GetField<uint64_t>(VT_STATICCONSTANTSSIZE, 0);
  }
  uint64_t dynamicConstantsSize() const {
    return GetField<uint64_t>(VT_DYNAMICCONSTANTSSIZE, 0);
  }
  uint64_t exitDoorbellOffset() const {
    return GetField<uint64_t>(VT_EXITDOORBELLOFFSET, 0);
  }
  uint32_t l2CachedDDRSize() const {
    return GetField<uint32_t>(VT_L2CACHEDDDRSIZE, 0);
  }
  uint32_t L2TCMInitSize() const {
    return GetField<uint32_t>(VT_L2TCMINITSIZE, 0);
  }
  uint16_t execContextMajorVersion() const {
    return GetField<uint16_t>(VT_EXECCONTEXTMAJORVERSION, 0);
  }
  uint16_t numNSPs() const { return GetField<uint16_t>(VT_NUMNSPS, 0); }
  uint16_t numSemaphores() const {
    return GetField<uint16_t>(VT_NUMSEMAPHORES, 0);
  }
  uint8_t hwVersionMajor() const {
    return GetField<uint8_t>(VT_HWVERSIONMAJOR, 0);
  }
  uint8_t hwVersionMinor() const {
    return GetField<uint8_t>(VT_HWVERSIONMINOR, 0);
  }
  uint8_t staticSharedDDRECCEnabled() const {
    return GetField<uint8_t>(VT_STATICSHAREDDDRECCENABLED, 0);
  }
  uint8_t dynamicSharedDDRECCEnabled() const {
    return GetField<uint8_t>(VT_DYNAMICSHAREDDDRECCENABLED, 0);
  }
  uint8_t staticConstantsECCEnabled() const {
    return GetField<uint8_t>(VT_STATICCONSTANTSECCENABLED, 0);
  }
  uint8_t dynamicConstantsECCEnabled() const {
    return GetField<uint8_t>(VT_DYNAMICCONSTANTSECCENABLED, 0);
  }
  uint8_t singleVTCMPage() const {
    return GetField<uint8_t>(VT_SINGLEVTCMPAGE, 0);
  }
  uint8_t hasHvxFP() const { return GetField<uint8_t>(VT_HASHVXFP, 0); }
  uint8_t hasHmxFP() const { return GetField<uint8_t>(VT_HASHMXFP, 0); }
  uint32_t VTCMSize() const { return GetField<uint32_t>(VT_VTCMSIZE, 0); }
  uint32_t L2TCMSize() const { return GetField<uint32_t>(VT_L2TCMSIZE, 0); }
  uint64_t networkHeapSize() const {
    return GetField<uint64_t>(VT_NETWORKHEAPSIZE, 0);
  }
  uint64_t raw_struct_version_length() const {
    return GetField<uint64_t>(VT_RAW_STRUCT_VERSION_LENGTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VERSIONMAJOR, 2) &&
           VerifyField<uint16_t>(verifier, VT_VERSIONMINOR, 2) &&
           VerifyOffset(verifier, VT_NETWORKNAME) &&
           verifier.VerifyString(networkName()) &&
           VerifyOffset(verifier, VT_REQUIREDFIELDS) &&
           verifier.VerifyVector(requiredFields()) &&
           verifier.VerifyVectorOfStrings(requiredFields()) &&
           VerifyOffset(verifier, VT_SEMAPHOREINITSTATE) &&
           verifier.VerifyVector(semaphoreInitState()) &&
           VerifyOffset(verifier, VT_L2TCMINITSTATE) &&
           verifier.VerifyVector(L2TCMInitState()) &&
           VerifyOffset(verifier, VT_DMAREQUESTS) &&
           verifier.VerifyVector(dmaRequests()) &&
           verifier.VerifyVectorOfTables(dmaRequests()) &&
           VerifyOffset(verifier, VT_NSPMULTICASTTABLES) &&
           verifier.VerifyVector(nspMulticastTables()) &&
           verifier.VerifyVectorOfTables(nspMulticastTables()) &&
           VerifyOffset(verifier, VT_HOSTMULTICASTTABLE) &&
           verifier.VerifyTable(hostMulticastTable()) &&
           VerifyOffset(verifier, VT_THREADDESCRIPTORS) &&
           verifier.VerifyVector(threadDescriptors()) &&
           verifier.VerifyVectorOfTables(threadDescriptors()) &&
           VerifyOffset(verifier, VT_CONSTANTMAPPINGS) &&
           verifier.VerifyVector(constantMappings()) &&
           verifier.VerifyVectorOfTables(constantMappings()) &&
           VerifyField<uint64_t>(verifier, VT_STATICSHAREDDDRSIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_DYNAMICSHAREDDDRSIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_STATICCONSTANTSSIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_DYNAMICCONSTANTSSIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_EXITDOORBELLOFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_L2CACHEDDDRSIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_L2TCMINITSIZE, 4) &&
           VerifyField<uint16_t>(verifier, VT_EXECCONTEXTMAJORVERSION, 2) &&
           VerifyField<uint16_t>(verifier, VT_NUMNSPS, 2) &&
           VerifyField<uint16_t>(verifier, VT_NUMSEMAPHORES, 2) &&
           VerifyField<uint8_t>(verifier, VT_HWVERSIONMAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_HWVERSIONMINOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_STATICSHAREDDDRECCENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMICSHAREDDDRECCENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_STATICCONSTANTSECCENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMICCONSTANTSECCENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_SINGLEVTCMPAGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_HASHVXFP, 1) &&
           VerifyField<uint8_t>(verifier, VT_HASHMXFP, 1) &&
           VerifyField<uint32_t>(verifier, VT_VTCMSIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_L2TCMSIZE, 4) &&
           VerifyField<uint64_t>(verifier, VT_NETWORKHEAPSIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_RAW_STRUCT_VERSION_LENGTH, 8) &&
           verifier.EndTable();
  }
  MetadataT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void
  UnPackTo(MetadataT *_o,
           const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Metadata>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetadataBuilder {
  typedef Metadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_versionMajor(uint16_t versionMajor) {
    fbb_.AddElement<uint16_t>(Metadata::VT_VERSIONMAJOR, versionMajor, 0);
  }
  void add_versionMinor(uint16_t versionMinor) {
    fbb_.AddElement<uint16_t>(Metadata::VT_VERSIONMINOR, versionMinor, 0);
  }
  void add_networkName(flatbuffers::Offset<flatbuffers::String> networkName) {
    fbb_.AddOffset(Metadata::VT_NETWORKNAME, networkName);
  }
  void add_requiredFields(
      flatbuffers::Offset<
          flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>>
          requiredFields) {
    fbb_.AddOffset(Metadata::VT_REQUIREDFIELDS, requiredFields);
  }
  void add_semaphoreInitState(
      flatbuffers::Offset<flatbuffers::Vector<uint32_t>> semaphoreInitState) {
    fbb_.AddOffset(Metadata::VT_SEMAPHOREINITSTATE, semaphoreInitState);
  }
  void add_L2TCMInitState(
      flatbuffers::Offset<flatbuffers::Vector<uint8_t>> L2TCMInitState) {
    fbb_.AddOffset(Metadata::VT_L2TCMINITSTATE, L2TCMInitState);
  }
  void
  add_dmaRequests(flatbuffers::Offset<flatbuffers::Vector<
                      flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>>>
                      dmaRequests) {
    fbb_.AddOffset(Metadata::VT_DMAREQUESTS, dmaRequests);
  }
  void add_nspMulticastTables(
      flatbuffers::Offset<flatbuffers::Vector<
          flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>>>
          nspMulticastTables) {
    fbb_.AddOffset(Metadata::VT_NSPMULTICASTTABLES, nspMulticastTables);
  }
  void add_hostMulticastTable(
      flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntryTable>
          hostMulticastTable) {
    fbb_.AddOffset(Metadata::VT_HOSTMULTICASTTABLE, hostMulticastTable);
  }
  void add_threadDescriptors(
      flatbuffers::Offset<flatbuffers::Vector<
          flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>>>
          threadDescriptors) {
    fbb_.AddOffset(Metadata::VT_THREADDESCRIPTORS, threadDescriptors);
  }
  void add_constantMappings(
      flatbuffers::Offset<flatbuffers::Vector<
          flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>>>
          constantMappings) {
    fbb_.AddOffset(Metadata::VT_CONSTANTMAPPINGS, constantMappings);
  }
  void add_staticSharedDDRSize(uint64_t staticSharedDDRSize) {
    fbb_.AddElement<uint64_t>(Metadata::VT_STATICSHAREDDDRSIZE,
                              staticSharedDDRSize, 0);
  }
  void add_dynamicSharedDDRSize(uint64_t dynamicSharedDDRSize) {
    fbb_.AddElement<uint64_t>(Metadata::VT_DYNAMICSHAREDDDRSIZE,
                              dynamicSharedDDRSize, 0);
  }
  void add_staticConstantsSize(uint64_t staticConstantsSize) {
    fbb_.AddElement<uint64_t>(Metadata::VT_STATICCONSTANTSSIZE,
                              staticConstantsSize, 0);
  }
  void add_dynamicConstantsSize(uint64_t dynamicConstantsSize) {
    fbb_.AddElement<uint64_t>(Metadata::VT_DYNAMICCONSTANTSSIZE,
                              dynamicConstantsSize, 0);
  }
  void add_exitDoorbellOffset(uint64_t exitDoorbellOffset) {
    fbb_.AddElement<uint64_t>(Metadata::VT_EXITDOORBELLOFFSET,
                              exitDoorbellOffset, 0);
  }
  void add_l2CachedDDRSize(uint32_t l2CachedDDRSize) {
    fbb_.AddElement<uint32_t>(Metadata::VT_L2CACHEDDDRSIZE, l2CachedDDRSize, 0);
  }
  void add_L2TCMInitSize(uint32_t L2TCMInitSize) {
    fbb_.AddElement<uint32_t>(Metadata::VT_L2TCMINITSIZE, L2TCMInitSize, 0);
  }
  void add_execContextMajorVersion(uint16_t execContextMajorVersion) {
    fbb_.AddElement<uint16_t>(Metadata::VT_EXECCONTEXTMAJORVERSION,
                              execContextMajorVersion, 0);
  }
  void add_numNSPs(uint16_t numNSPs) {
    fbb_.AddElement<uint16_t>(Metadata::VT_NUMNSPS, numNSPs, 0);
  }
  void add_numSemaphores(uint16_t numSemaphores) {
    fbb_.AddElement<uint16_t>(Metadata::VT_NUMSEMAPHORES, numSemaphores, 0);
  }
  void add_hwVersionMajor(uint8_t hwVersionMajor) {
    fbb_.AddElement<uint8_t>(Metadata::VT_HWVERSIONMAJOR, hwVersionMajor, 0);
  }
  void add_hwVersionMinor(uint8_t hwVersionMinor) {
    fbb_.AddElement<uint8_t>(Metadata::VT_HWVERSIONMINOR, hwVersionMinor, 0);
  }
  void add_staticSharedDDRECCEnabled(uint8_t staticSharedDDRECCEnabled) {
    fbb_.AddElement<uint8_t>(Metadata::VT_STATICSHAREDDDRECCENABLED,
                             staticSharedDDRECCEnabled, 0);
  }
  void add_dynamicSharedDDRECCEnabled(uint8_t dynamicSharedDDRECCEnabled) {
    fbb_.AddElement<uint8_t>(Metadata::VT_DYNAMICSHAREDDDRECCENABLED,
                             dynamicSharedDDRECCEnabled, 0);
  }
  void add_staticConstantsECCEnabled(uint8_t staticConstantsECCEnabled) {
    fbb_.AddElement<uint8_t>(Metadata::VT_STATICCONSTANTSECCENABLED,
                             staticConstantsECCEnabled, 0);
  }
  void add_dynamicConstantsECCEnabled(uint8_t dynamicConstantsECCEnabled) {
    fbb_.AddElement<uint8_t>(Metadata::VT_DYNAMICCONSTANTSECCENABLED,
                             dynamicConstantsECCEnabled, 0);
  }
  void add_singleVTCMPage(uint8_t singleVTCMPage) {
    fbb_.AddElement<uint8_t>(Metadata::VT_SINGLEVTCMPAGE, singleVTCMPage, 0);
  }
  void add_hasHvxFP(uint8_t hasHvxFP) {
    fbb_.AddElement<uint8_t>(Metadata::VT_HASHVXFP, hasHvxFP, 0);
  }
  void add_hasHmxFP(uint8_t hasHmxFP) {
    fbb_.AddElement<uint8_t>(Metadata::VT_HASHMXFP, hasHmxFP, 0);
  }
  void add_VTCMSize(uint32_t VTCMSize) {
    fbb_.AddElement<uint32_t>(Metadata::VT_VTCMSIZE, VTCMSize, 0);
  }
  void add_L2TCMSize(uint32_t L2TCMSize) {
    fbb_.AddElement<uint32_t>(Metadata::VT_L2TCMSIZE, L2TCMSize, 0);
  }
  void add_networkHeapSize(uint64_t networkHeapSize) {
    fbb_.AddElement<uint64_t>(Metadata::VT_NETWORKHEAPSIZE, networkHeapSize, 0);
  }
  void add_raw_struct_version_length(uint64_t raw_struct_version_length) {
    fbb_.AddElement<uint64_t>(Metadata::VT_RAW_STRUCT_VERSION_LENGTH,
                              raw_struct_version_length, 0);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb, uint16_t versionMajor = 0,
    uint16_t versionMinor = 0,
    flatbuffers::Offset<flatbuffers::String> networkName = 0,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>>
        requiredFields = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> semaphoreInitState = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> L2TCMInitState = 0,
    flatbuffers::Offset<flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>>>
        dmaRequests = 0,
    flatbuffers::Offset<flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>>>
        nspMulticastTables = 0,
    flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntryTable>
        hostMulticastTable = 0,
    flatbuffers::Offset<flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>>>
        threadDescriptors = 0,
    flatbuffers::Offset<flatbuffers::Vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>>>
        constantMappings = 0,
    uint64_t staticSharedDDRSize = 0, uint64_t dynamicSharedDDRSize = 0,
    uint64_t staticConstantsSize = 0, uint64_t dynamicConstantsSize = 0,
    uint64_t exitDoorbellOffset = 0, uint32_t l2CachedDDRSize = 0,
    uint32_t L2TCMInitSize = 0, uint16_t execContextMajorVersion = 0,
    uint16_t numNSPs = 0, uint16_t numSemaphores = 0,
    uint8_t hwVersionMajor = 0, uint8_t hwVersionMinor = 0,
    uint8_t staticSharedDDRECCEnabled = 0,
    uint8_t dynamicSharedDDRECCEnabled = 0,
    uint8_t staticConstantsECCEnabled = 0,
    uint8_t dynamicConstantsECCEnabled = 0, uint8_t singleVTCMPage = 0,
    uint8_t hasHvxFP = 0, uint8_t hasHmxFP = 0, uint32_t VTCMSize = 0,
    uint32_t L2TCMSize = 0, uint64_t networkHeapSize = 0,
    uint64_t raw_struct_version_length = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_raw_struct_version_length(raw_struct_version_length);
  builder_.add_networkHeapSize(networkHeapSize);
  builder_.add_exitDoorbellOffset(exitDoorbellOffset);
  builder_.add_dynamicConstantsSize(dynamicConstantsSize);
  builder_.add_staticConstantsSize(staticConstantsSize);
  builder_.add_dynamicSharedDDRSize(dynamicSharedDDRSize);
  builder_.add_staticSharedDDRSize(staticSharedDDRSize);
  builder_.add_L2TCMSize(L2TCMSize);
  builder_.add_VTCMSize(VTCMSize);
  builder_.add_L2TCMInitSize(L2TCMInitSize);
  builder_.add_l2CachedDDRSize(l2CachedDDRSize);
  builder_.add_constantMappings(constantMappings);
  builder_.add_threadDescriptors(threadDescriptors);
  builder_.add_hostMulticastTable(hostMulticastTable);
  builder_.add_nspMulticastTables(nspMulticastTables);
  builder_.add_dmaRequests(dmaRequests);
  builder_.add_L2TCMInitState(L2TCMInitState);
  builder_.add_semaphoreInitState(semaphoreInitState);
  builder_.add_requiredFields(requiredFields);
  builder_.add_networkName(networkName);
  builder_.add_numSemaphores(numSemaphores);
  builder_.add_numNSPs(numNSPs);
  builder_.add_execContextMajorVersion(execContextMajorVersion);
  builder_.add_versionMinor(versionMinor);
  builder_.add_versionMajor(versionMajor);
  builder_.add_hasHmxFP(hasHmxFP);
  builder_.add_hasHvxFP(hasHvxFP);
  builder_.add_singleVTCMPage(singleVTCMPage);
  builder_.add_dynamicConstantsECCEnabled(dynamicConstantsECCEnabled);
  builder_.add_staticConstantsECCEnabled(staticConstantsECCEnabled);
  builder_.add_dynamicSharedDDRECCEnabled(dynamicSharedDDRECCEnabled);
  builder_.add_staticSharedDDRECCEnabled(staticSharedDDRECCEnabled);
  builder_.add_hwVersionMinor(hwVersionMinor);
  builder_.add_hwVersionMajor(hwVersionMajor);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb, uint16_t versionMajor = 0,
    uint16_t versionMinor = 0, const char *networkName = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>>
        *requiredFields = nullptr,
    const std::vector<uint32_t> *semaphoreInitState = nullptr,
    const std::vector<uint8_t> *L2TCMInitState = nullptr,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>>
        *dmaRequests = nullptr,
    const std::vector<
        flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>>
        *nspMulticastTables = nullptr,
    flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntryTable>
        hostMulticastTable = 0,
    const std::vector<flatbuffers::Offset<
        AicMetadataFlat::AICMDThreadDescriptor>> *threadDescriptors = nullptr,
    const std::vector<flatbuffers::Offset<
        AicMetadataFlat::AICMDConstantMapping>> *constantMappings = nullptr,
    uint64_t staticSharedDDRSize = 0, uint64_t dynamicSharedDDRSize = 0,
    uint64_t staticConstantsSize = 0, uint64_t dynamicConstantsSize = 0,
    uint64_t exitDoorbellOffset = 0, uint32_t l2CachedDDRSize = 0,
    uint32_t L2TCMInitSize = 0, uint16_t execContextMajorVersion = 0,
    uint16_t numNSPs = 0, uint16_t numSemaphores = 0,
    uint8_t hwVersionMajor = 0, uint8_t hwVersionMinor = 0,
    uint8_t staticSharedDDRECCEnabled = 0,
    uint8_t dynamicSharedDDRECCEnabled = 0,
    uint8_t staticConstantsECCEnabled = 0,
    uint8_t dynamicConstantsECCEnabled = 0, uint8_t singleVTCMPage = 0,
    uint8_t hasHvxFP = 0, uint8_t hasHmxFP = 0, uint32_t VTCMSize = 0,
    uint32_t L2TCMSize = 0, uint64_t networkHeapSize = 0,
    uint64_t raw_struct_version_length = 0) {
  auto networkName__ = networkName ? _fbb.CreateString(networkName) : 0;
  auto requiredFields__ =
      requiredFields
          ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
                *requiredFields)
          : 0;
  auto semaphoreInitState__ =
      semaphoreInitState ? _fbb.CreateVector<uint32_t>(*semaphoreInitState) : 0;
  auto L2TCMInitState__ =
      L2TCMInitState ? _fbb.CreateVector<uint8_t>(*L2TCMInitState) : 0;
  auto dmaRequests__ =
      dmaRequests
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>>(
                *dmaRequests)
          : 0;
  auto nspMulticastTables__ =
      nspMulticastTables
          ? _fbb.CreateVector<flatbuffers::Offset<
                AicMetadataFlat::AICMDNSPMulticastEntryTable>>(
                *nspMulticastTables)
          : 0;
  auto threadDescriptors__ =
      threadDescriptors
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>>(
                *threadDescriptors)
          : 0;
  auto constantMappings__ =
      constantMappings
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>>(
                *constantMappings)
          : 0;
  return AicMetadataFlat::CreateMetadata(
      _fbb, versionMajor, versionMinor, networkName__, requiredFields__,
      semaphoreInitState__, L2TCMInitState__, dmaRequests__,
      nspMulticastTables__, hostMulticastTable, threadDescriptors__,
      constantMappings__, staticSharedDDRSize, dynamicSharedDDRSize,
      staticConstantsSize, dynamicConstantsSize, exitDoorbellOffset,
      l2CachedDDRSize, L2TCMInitSize, execContextMajorVersion, numNSPs,
      numSemaphores, hwVersionMajor, hwVersionMinor, staticSharedDDRECCEnabled,
      dynamicSharedDDRECCEnabled, staticConstantsECCEnabled,
      dynamicConstantsECCEnabled, singleVTCMPage, hasHvxFP, hasHmxFP, VTCMSize,
      L2TCMSize, networkHeapSize, raw_struct_version_length);
}

flatbuffers::Offset<Metadata>
CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
               const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline execContextT *
execContext::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<execContextT>(new execContextT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
execContext::UnPackTo(execContextT *_o,
                      const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = execContextSize();
    _o->execContextSize = _e;
  }
  {
    auto _e = execContextFields();
    if (_e) {
      _o->execContextFields.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        _o->execContextFields[_i] = *_e->Get(_i);
      }
    } else {
      _o->execContextFields.resize(0);
    }
  }
}

inline flatbuffers::Offset<execContext>
execContext::Pack(flatbuffers::FlatBufferBuilder &_fbb, const execContextT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateexecContext(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<execContext>
CreateexecContext(flatbuffers::FlatBufferBuilder &_fbb, const execContextT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const execContextT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _execContextSize = _o->execContextSize;
  auto _execContextFields =
      _o->execContextFields.size()
          ? _fbb.CreateVectorOfStructs(_o->execContextFields)
          : 0;
  return AicMetadataFlat::CreateexecContext(_fbb, _execContextSize,
                                            _execContextFields);
}

inline AICMDSemaphoreOpT *AICMDSemaphoreOp::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDSemaphoreOpT>(new AICMDSemaphoreOpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDSemaphoreOp::UnPackTo(
    AICMDSemaphoreOpT *_o,
    const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = semNum();
    _o->semNum = _e;
  }
  {
    auto _e = semValue();
    _o->semValue = _e;
  }
  {
    auto _e = semOp();
    _o->semOp = _e;
  }
  {
    auto _e = preOrPost();
    _o->preOrPost = _e;
  }
  {
    auto _e = inSyncFence();
    _o->inSyncFence = _e;
  }
  {
    auto _e = outSyncFence();
    _o->outSyncFence = _e;
  }
}

inline flatbuffers::Offset<AICMDSemaphoreOp>
AICMDSemaphoreOp::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                       const AICMDSemaphoreOpT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDSemaphoreOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDSemaphoreOp>
CreateAICMDSemaphoreOp(flatbuffers::FlatBufferBuilder &_fbb,
                       const AICMDSemaphoreOpT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AICMDSemaphoreOpT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _semNum = _o->semNum;
  auto _semValue = _o->semValue;
  auto _semOp = _o->semOp;
  auto _preOrPost = _o->preOrPost;
  auto _inSyncFence = _o->inSyncFence;
  auto _outSyncFence = _o->outSyncFence;
  return AicMetadataFlat::CreateAICMDSemaphoreOp(_fbb, _semNum, _semValue,
                                                 _semOp, _preOrPost,
                                                 _inSyncFence, _outSyncFence);
}

inline AICMDDoorbellOpT *AICMDDoorbellOp::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDDoorbellOpT>(new AICMDDoorbellOpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDDoorbellOp::UnPackTo(
    AICMDDoorbellOpT *_o,
    const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = offset();
    _o->offset = _e;
  }
  {
    auto _e = data();
    _o->data = _e;
  }
  {
    auto _e = mcId();
    _o->mcId = _e;
  }
  {
    auto _e = size();
    _o->size = _e;
  }
}

inline flatbuffers::Offset<AICMDDoorbellOp>
AICMDDoorbellOp::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                      const AICMDDoorbellOpT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDDoorbellOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDDoorbellOp>
CreateAICMDDoorbellOp(flatbuffers::FlatBufferBuilder &_fbb,
                      const AICMDDoorbellOpT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AICMDDoorbellOpT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _offset = _o->offset;
  auto _data = _o->data;
  auto _mcId = _o->mcId;
  auto _size = _o->size;
  return AicMetadataFlat::CreateAICMDDoorbellOp(_fbb, _offset, _data, _mcId,
                                                _size);
}

inline AICMDDMARequestT::AICMDDMARequestT(const AICMDDMARequestT &o)
    : hostOffset(o.hostOffset), devOffset(o.devOffset), size(o.size),
      num(o.num), mcId(o.mcId), devAddrSpace(o.devAddrSpace), inOut(o.inOut),
      portId(o.portId) {
  semaphoreOps.reserve(o.semaphoreOps.size());
  for (const auto &semaphoreOps_ : o.semaphoreOps) {
    semaphoreOps.emplace_back(
        (semaphoreOps_) ? new AicMetadataFlat::AICMDSemaphoreOpT(*semaphoreOps_)
                        : nullptr);
  }
  doorbellOps.reserve(o.doorbellOps.size());
  for (const auto &doorbellOps_ : o.doorbellOps) {
    doorbellOps.emplace_back(
        (doorbellOps_) ? new AicMetadataFlat::AICMDDoorbellOpT(*doorbellOps_)
                       : nullptr);
  }
}

inline AICMDDMARequestT &AICMDDMARequestT::
operator=(AICMDDMARequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(semaphoreOps, o.semaphoreOps);
  std::swap(doorbellOps, o.doorbellOps);
  std::swap(hostOffset, o.hostOffset);
  std::swap(devOffset, o.devOffset);
  std::swap(size, o.size);
  std::swap(num, o.num);
  std::swap(mcId, o.mcId);
  std::swap(devAddrSpace, o.devAddrSpace);
  std::swap(inOut, o.inOut);
  std::swap(portId, o.portId);
  return *this;
}

inline AICMDDMARequestT *AICMDDMARequest::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDDMARequestT>(new AICMDDMARequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDDMARequest::UnPackTo(
    AICMDDMARequestT *_o,
    const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = semaphoreOps();
    if (_e) {
      _o->semaphoreOps.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        if (_o->semaphoreOps[_i]) {
          _e->Get(_i)->UnPackTo(_o->semaphoreOps[_i].get(), _resolver);
        } else {
          _o->semaphoreOps[_i] =
              std::unique_ptr<AicMetadataFlat::AICMDSemaphoreOpT>(
                  _e->Get(_i)->UnPack(_resolver));
        };
      }
    } else {
      _o->semaphoreOps.resize(0);
    }
  }
  {
    auto _e = doorbellOps();
    if (_e) {
      _o->doorbellOps.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        if (_o->doorbellOps[_i]) {
          _e->Get(_i)->UnPackTo(_o->doorbellOps[_i].get(), _resolver);
        } else {
          _o->doorbellOps[_i] =
              std::unique_ptr<AicMetadataFlat::AICMDDoorbellOpT>(
                  _e->Get(_i)->UnPack(_resolver));
        };
      }
    } else {
      _o->doorbellOps.resize(0);
    }
  }
  {
    auto _e = hostOffset();
    _o->hostOffset = _e;
  }
  {
    auto _e = devOffset();
    _o->devOffset = _e;
  }
  {
    auto _e = size();
    _o->size = _e;
  }
  {
    auto _e = num();
    _o->num = _e;
  }
  {
    auto _e = mcId();
    _o->mcId = _e;
  }
  {
    auto _e = devAddrSpace();
    _o->devAddrSpace = _e;
  }
  {
    auto _e = inOut();
    _o->inOut = _e;
  }
  {
    auto _e = portId();
    _o->portId = _e;
  }
}

inline flatbuffers::Offset<AICMDDMARequest>
AICMDDMARequest::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                      const AICMDDMARequestT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDDMARequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDDMARequest>
CreateAICMDDMARequest(flatbuffers::FlatBufferBuilder &_fbb,
                      const AICMDDMARequestT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AICMDDMARequestT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _semaphoreOps =
      _o->semaphoreOps.size()
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>>(
                _o->semaphoreOps.size(),
                [](size_t i, _VectorArgs *__va) {
                  return CreateAICMDSemaphoreOp(
                      *__va->__fbb, __va->__o->semaphoreOps[i].get(),
                      __va->__rehasher);
                },
                &_va)
          : 0;
  auto _doorbellOps =
      _o->doorbellOps.size()
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>>(
                _o->doorbellOps.size(),
                [](size_t i, _VectorArgs *__va) {
                  return CreateAICMDDoorbellOp(*__va->__fbb,
                                               __va->__o->doorbellOps[i].get(),
                                               __va->__rehasher);
                },
                &_va)
          : 0;
  auto _hostOffset = _o->hostOffset;
  auto _devOffset = _o->devOffset;
  auto _size = _o->size;
  auto _num = _o->num;
  auto _mcId = _o->mcId;
  auto _devAddrSpace = _o->devAddrSpace;
  auto _inOut = _o->inOut;
  auto _portId = _o->portId;
  return AicMetadataFlat::CreateAICMDDMARequest(
      _fbb, _semaphoreOps, _doorbellOps, _hostOffset, _devOffset, _size, _num,
      _mcId, _devAddrSpace, _inOut, _portId);
}

inline AICMDNSPMulticastEntryT *AICMDNSPMulticastEntry::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
  auto _o =
      std::unique_ptr<AICMDNSPMulticastEntryT>(new AICMDNSPMulticastEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDNSPMulticastEntry::UnPackTo(
    AICMDNSPMulticastEntryT *_o,
    const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = baseAddrOffset();
    _o->baseAddrOffset = _e;
  }
  {
    auto _e = mask();
    _o->mask = _e;
  }
  {
    auto _e = size();
    _o->size = _e;
  }
  {
    auto _e = addrSpace();
    _o->addrSpace = _e;
  }
  {
    auto _e = dynamic();
    _o->dynamic = _e;
  }
}

inline flatbuffers::Offset<AICMDNSPMulticastEntry> AICMDNSPMulticastEntry::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDNSPMulticastEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDNSPMulticastEntry> CreateAICMDNSPMulticastEntry(
    flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AICMDNSPMulticastEntryT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _baseAddrOffset = _o->baseAddrOffset;
  auto _mask = _o->mask;
  auto _size = _o->size;
  auto _addrSpace = _o->addrSpace;
  auto _dynamic = _o->dynamic;
  return AicMetadataFlat::CreateAICMDNSPMulticastEntry(
      _fbb, _baseAddrOffset, _mask, _size, _addrSpace, _dynamic);
}

inline AICMDNSPMulticastEntryTableT::AICMDNSPMulticastEntryTableT(
    const AICMDNSPMulticastEntryTableT &o) {
  multicastEntries.reserve(o.multicastEntries.size());
  for (const auto &multicastEntries_ : o.multicastEntries) {
    multicastEntries.emplace_back(
        (multicastEntries_)
            ? new AicMetadataFlat::AICMDNSPMulticastEntryT(*multicastEntries_)
            : nullptr);
  }
}

inline AICMDNSPMulticastEntryTableT &AICMDNSPMulticastEntryTableT::
operator=(AICMDNSPMulticastEntryTableT o) FLATBUFFERS_NOEXCEPT {
  std::swap(multicastEntries, o.multicastEntries);
  return *this;
}

inline AICMDNSPMulticastEntryTableT *AICMDNSPMulticastEntryTable::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDNSPMulticastEntryTableT>(
      new AICMDNSPMulticastEntryTableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDNSPMulticastEntryTable::UnPackTo(
    AICMDNSPMulticastEntryTableT *_o,
    const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = multicastEntries();
    if (_e) {
      _o->multicastEntries.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        if (_o->multicastEntries[_i]) {
          _e->Get(_i)->UnPackTo(_o->multicastEntries[_i].get(), _resolver);
        } else {
          _o->multicastEntries[_i] =
              std::unique_ptr<AicMetadataFlat::AICMDNSPMulticastEntryT>(
                  _e->Get(_i)->UnPack(_resolver));
        };
      }
    } else {
      _o->multicastEntries.resize(0);
    }
  }
}

inline flatbuffers::Offset<AICMDNSPMulticastEntryTable>
AICMDNSPMulticastEntryTable::Pack(
    flatbuffers::FlatBufferBuilder &_fbb,
    const AICMDNSPMulticastEntryTableT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDNSPMulticastEntryTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDNSPMulticastEntryTable>
CreateAICMDNSPMulticastEntryTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    const AICMDNSPMulticastEntryTableT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AICMDNSPMulticastEntryTableT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _multicastEntries =
      _o->multicastEntries.size()
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>>(
                _o->multicastEntries.size(),
                [](size_t i, _VectorArgs *__va) {
                  return CreateAICMDNSPMulticastEntry(
                      *__va->__fbb, __va->__o->multicastEntries[i].get(),
                      __va->__rehasher);
                },
                &_va)
          : 0;
  return AicMetadataFlat::CreateAICMDNSPMulticastEntryTable(_fbb,
                                                            _multicastEntries);
}

inline AICMDHostMulticastEntryT *AICMDHostMulticastEntry::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
  auto _o =
      std::unique_ptr<AICMDHostMulticastEntryT>(new AICMDHostMulticastEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDHostMulticastEntry::UnPackTo(
    AICMDHostMulticastEntryT *_o,
    const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = mask();
    _o->mask = _e;
  }
  {
    auto _e = size();
    _o->size = _e;
  }
}

inline flatbuffers::Offset<AICMDHostMulticastEntry>
AICMDHostMulticastEntry::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDHostMulticastEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDHostMulticastEntry>
CreateAICMDHostMulticastEntry(
    flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AICMDHostMulticastEntryT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _mask = _o->mask;
  auto _size = _o->size;
  return AicMetadataFlat::CreateAICMDHostMulticastEntry(_fbb, _mask, _size);
}

inline AICMDHostMulticastEntryTableT::AICMDHostMulticastEntryTableT(
    const AICMDHostMulticastEntryTableT &o) {
  multicastEntries.reserve(o.multicastEntries.size());
  for (const auto &multicastEntries_ : o.multicastEntries) {
    multicastEntries.emplace_back(
        (multicastEntries_)
            ? new AicMetadataFlat::AICMDHostMulticastEntryT(*multicastEntries_)
            : nullptr);
  }
}

inline AICMDHostMulticastEntryTableT &AICMDHostMulticastEntryTableT::
operator=(AICMDHostMulticastEntryTableT o) FLATBUFFERS_NOEXCEPT {
  std::swap(multicastEntries, o.multicastEntries);
  return *this;
}

inline AICMDHostMulticastEntryTableT *AICMDHostMulticastEntryTable::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDHostMulticastEntryTableT>(
      new AICMDHostMulticastEntryTableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDHostMulticastEntryTable::UnPackTo(
    AICMDHostMulticastEntryTableT *_o,
    const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = multicastEntries();
    if (_e) {
      _o->multicastEntries.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        if (_o->multicastEntries[_i]) {
          _e->Get(_i)->UnPackTo(_o->multicastEntries[_i].get(), _resolver);
        } else {
          _o->multicastEntries[_i] =
              std::unique_ptr<AicMetadataFlat::AICMDHostMulticastEntryT>(
                  _e->Get(_i)->UnPack(_resolver));
        };
      }
    } else {
      _o->multicastEntries.resize(0);
    }
  }
}

inline flatbuffers::Offset<AICMDHostMulticastEntryTable>
AICMDHostMulticastEntryTable::Pack(
    flatbuffers::FlatBufferBuilder &_fbb,
    const AICMDHostMulticastEntryTableT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDHostMulticastEntryTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDHostMulticastEntryTable>
CreateAICMDHostMulticastEntryTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    const AICMDHostMulticastEntryTableT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AICMDHostMulticastEntryTableT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _multicastEntries =
      _o->multicastEntries.size()
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>>(
                _o->multicastEntries.size(),
                [](size_t i, _VectorArgs *__va) {
                  return CreateAICMDHostMulticastEntry(
                      *__va->__fbb, __va->__o->multicastEntries[i].get(),
                      __va->__rehasher);
                },
                &_va)
          : 0;
  return AicMetadataFlat::CreateAICMDHostMulticastEntryTable(_fbb,
                                                             _multicastEntries);
}

inline AICMDThreadDescriptorT *AICMDThreadDescriptor::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
  auto _o =
      std::unique_ptr<AICMDThreadDescriptorT>(new AICMDThreadDescriptorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDThreadDescriptor::UnPackTo(
    AICMDThreadDescriptorT *_o,
    const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = entryPoint();
    _o->entryPoint = _e;
  }
  {
    auto _e = typeMask();
    _o->typeMask = _e;
  }
}

inline flatbuffers::Offset<AICMDThreadDescriptor>
AICMDThreadDescriptor::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                            const AICMDThreadDescriptorT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDThreadDescriptor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDThreadDescriptor>
CreateAICMDThreadDescriptor(flatbuffers::FlatBufferBuilder &_fbb,
                            const AICMDThreadDescriptorT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AICMDThreadDescriptorT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _entryPoint = _o->entryPoint;
  auto _typeMask = _o->typeMask;
  return AicMetadataFlat::CreateAICMDThreadDescriptor(_fbb, _entryPoint,
                                                      _typeMask);
}

inline AICMDConstantMappingT *AICMDConstantMapping::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDConstantMappingT>(new AICMDConstantMappingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDConstantMapping::UnPackTo(
    AICMDConstantMappingT *_o,
    const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = constantDataBaseOffset();
    _o->constantDataBaseOffset = _e;
  }
  {
    auto _e = coreMask();
    _o->coreMask = _e;
  }
  {
    auto _e = size();
    _o->size = _e;
  }
}

inline flatbuffers::Offset<AICMDConstantMapping>
AICMDConstantMapping::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                           const AICMDConstantMappingT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDConstantMapping(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDConstantMapping>
CreateAICMDConstantMapping(flatbuffers::FlatBufferBuilder &_fbb,
                           const AICMDConstantMappingT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AICMDConstantMappingT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _constantDataBaseOffset = _o->constantDataBaseOffset;
  auto _coreMask = _o->coreMask;
  auto _size = _o->size;
  return AicMetadataFlat::CreateAICMDConstantMapping(
      _fbb, _constantDataBaseOffset, _coreMask, _size);
}

inline MetadataT::MetadataT(const MetadataT &o)
    : versionMajor(o.versionMajor), versionMinor(o.versionMinor),
      networkName(o.networkName), requiredFields(o.requiredFields),
      semaphoreInitState(o.semaphoreInitState),
      L2TCMInitState(o.L2TCMInitState),
      hostMulticastTable(
          (o.hostMulticastTable)
              ? new AicMetadataFlat::AICMDHostMulticastEntryTableT(
                    *o.hostMulticastTable)
              : nullptr),
      staticSharedDDRSize(o.staticSharedDDRSize),
      dynamicSharedDDRSize(o.dynamicSharedDDRSize),
      staticConstantsSize(o.staticConstantsSize),
      dynamicConstantsSize(o.dynamicConstantsSize),
      exitDoorbellOffset(o.exitDoorbellOffset),
      l2CachedDDRSize(o.l2CachedDDRSize), L2TCMInitSize(o.L2TCMInitSize),
      execContextMajorVersion(o.execContextMajorVersion), numNSPs(o.numNSPs),
      numSemaphores(o.numSemaphores), hwVersionMajor(o.hwVersionMajor),
      hwVersionMinor(o.hwVersionMinor),
      staticSharedDDRECCEnabled(o.staticSharedDDRECCEnabled),
      dynamicSharedDDRECCEnabled(o.dynamicSharedDDRECCEnabled),
      staticConstantsECCEnabled(o.staticConstantsECCEnabled),
      dynamicConstantsECCEnabled(o.dynamicConstantsECCEnabled),
      singleVTCMPage(o.singleVTCMPage), hasHvxFP(o.hasHvxFP),
      hasHmxFP(o.hasHmxFP), VTCMSize(o.VTCMSize), L2TCMSize(o.L2TCMSize),
      networkHeapSize(o.networkHeapSize),
      raw_struct_version_length(o.raw_struct_version_length) {
  dmaRequests.reserve(o.dmaRequests.size());
  for (const auto &dmaRequests_ : o.dmaRequests) {
    dmaRequests.emplace_back(
        (dmaRequests_) ? new AicMetadataFlat::AICMDDMARequestT(*dmaRequests_)
                       : nullptr);
  }
  nspMulticastTables.reserve(o.nspMulticastTables.size());
  for (const auto &nspMulticastTables_ : o.nspMulticastTables) {
    nspMulticastTables.emplace_back(
        (nspMulticastTables_)
            ? new AicMetadataFlat::AICMDNSPMulticastEntryTableT(
                  *nspMulticastTables_)
            : nullptr);
  }
  threadDescriptors.reserve(o.threadDescriptors.size());
  for (const auto &threadDescriptors_ : o.threadDescriptors) {
    threadDescriptors.emplace_back(
        (threadDescriptors_)
            ? new AicMetadataFlat::AICMDThreadDescriptorT(*threadDescriptors_)
            : nullptr);
  }
  constantMappings.reserve(o.constantMappings.size());
  for (const auto &constantMappings_ : o.constantMappings) {
    constantMappings.emplace_back(
        (constantMappings_)
            ? new AicMetadataFlat::AICMDConstantMappingT(*constantMappings_)
            : nullptr);
  }
}

inline MetadataT &MetadataT::operator=(MetadataT o) FLATBUFFERS_NOEXCEPT {
  std::swap(versionMajor, o.versionMajor);
  std::swap(versionMinor, o.versionMinor);
  std::swap(networkName, o.networkName);
  std::swap(requiredFields, o.requiredFields);
  std::swap(semaphoreInitState, o.semaphoreInitState);
  std::swap(L2TCMInitState, o.L2TCMInitState);
  std::swap(dmaRequests, o.dmaRequests);
  std::swap(nspMulticastTables, o.nspMulticastTables);
  std::swap(hostMulticastTable, o.hostMulticastTable);
  std::swap(threadDescriptors, o.threadDescriptors);
  std::swap(constantMappings, o.constantMappings);
  std::swap(staticSharedDDRSize, o.staticSharedDDRSize);
  std::swap(dynamicSharedDDRSize, o.dynamicSharedDDRSize);
  std::swap(staticConstantsSize, o.staticConstantsSize);
  std::swap(dynamicConstantsSize, o.dynamicConstantsSize);
  std::swap(exitDoorbellOffset, o.exitDoorbellOffset);
  std::swap(l2CachedDDRSize, o.l2CachedDDRSize);
  std::swap(L2TCMInitSize, o.L2TCMInitSize);
  std::swap(execContextMajorVersion, o.execContextMajorVersion);
  std::swap(numNSPs, o.numNSPs);
  std::swap(numSemaphores, o.numSemaphores);
  std::swap(hwVersionMajor, o.hwVersionMajor);
  std::swap(hwVersionMinor, o.hwVersionMinor);
  std::swap(staticSharedDDRECCEnabled, o.staticSharedDDRECCEnabled);
  std::swap(dynamicSharedDDRECCEnabled, o.dynamicSharedDDRECCEnabled);
  std::swap(staticConstantsECCEnabled, o.staticConstantsECCEnabled);
  std::swap(dynamicConstantsECCEnabled, o.dynamicConstantsECCEnabled);
  std::swap(singleVTCMPage, o.singleVTCMPage);
  std::swap(hasHvxFP, o.hasHvxFP);
  std::swap(hasHmxFP, o.hasHmxFP);
  std::swap(VTCMSize, o.VTCMSize);
  std::swap(L2TCMSize, o.L2TCMSize);
  std::swap(networkHeapSize, o.networkHeapSize);
  std::swap(raw_struct_version_length, o.raw_struct_version_length);
  return *this;
}

inline MetadataT *
Metadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MetadataT>(new MetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
Metadata::UnPackTo(MetadataT *_o,
                   const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = versionMajor();
    _o->versionMajor = _e;
  }
  {
    auto _e = versionMinor();
    _o->versionMinor = _e;
  }
  {
    auto _e = networkName();
    if (_e)
      _o->networkName = _e->str();
  }
  {
    auto _e = requiredFields();
    if (_e) {
      _o->requiredFields.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        _o->requiredFields[_i] = _e->Get(_i)->str();
      }
    } else {
      _o->requiredFields.resize(0);
    }
  }
  {
    auto _e = semaphoreInitState();
    if (_e) {
      _o->semaphoreInitState.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        _o->semaphoreInitState[_i] = _e->Get(_i);
      }
    } else {
      _o->semaphoreInitState.resize(0);
    }
  }
  {
    auto _e = L2TCMInitState();
    if (_e) {
      _o->L2TCMInitState.resize(_e->size());
      std::copy(_e->begin(), _e->end(), _o->L2TCMInitState.begin());
    }
  }
  {
    auto _e = dmaRequests();
    if (_e) {
      _o->dmaRequests.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        if (_o->dmaRequests[_i]) {
          _e->Get(_i)->UnPackTo(_o->dmaRequests[_i].get(), _resolver);
        } else {
          _o->dmaRequests[_i] =
              std::unique_ptr<AicMetadataFlat::AICMDDMARequestT>(
                  _e->Get(_i)->UnPack(_resolver));
        };
      }
    } else {
      _o->dmaRequests.resize(0);
    }
  }
  {
    auto _e = nspMulticastTables();
    if (_e) {
      _o->nspMulticastTables.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        if (_o->nspMulticastTables[_i]) {
          _e->Get(_i)->UnPackTo(_o->nspMulticastTables[_i].get(), _resolver);
        } else {
          _o->nspMulticastTables[_i] =
              std::unique_ptr<AicMetadataFlat::AICMDNSPMulticastEntryTableT>(
                  _e->Get(_i)->UnPack(_resolver));
        };
      }
    } else {
      _o->nspMulticastTables.resize(0);
    }
  }
  {
    auto _e = hostMulticastTable();
    if (_e) {
      if (_o->hostMulticastTable) {
        _e->UnPackTo(_o->hostMulticastTable.get(), _resolver);
      } else {
        _o->hostMulticastTable =
            std::unique_ptr<AicMetadataFlat::AICMDHostMulticastEntryTableT>(
                _e->UnPack(_resolver));
      }
    } else if (_o->hostMulticastTable) {
      _o->hostMulticastTable.reset();
    }
  }
  {
    auto _e = threadDescriptors();
    if (_e) {
      _o->threadDescriptors.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        if (_o->threadDescriptors[_i]) {
          _e->Get(_i)->UnPackTo(_o->threadDescriptors[_i].get(), _resolver);
        } else {
          _o->threadDescriptors[_i] =
              std::unique_ptr<AicMetadataFlat::AICMDThreadDescriptorT>(
                  _e->Get(_i)->UnPack(_resolver));
        };
      }
    } else {
      _o->threadDescriptors.resize(0);
    }
  }
  {
    auto _e = constantMappings();
    if (_e) {
      _o->constantMappings.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        if (_o->constantMappings[_i]) {
          _e->Get(_i)->UnPackTo(_o->constantMappings[_i].get(), _resolver);
        } else {
          _o->constantMappings[_i] =
              std::unique_ptr<AicMetadataFlat::AICMDConstantMappingT>(
                  _e->Get(_i)->UnPack(_resolver));
        };
      }
    } else {
      _o->constantMappings.resize(0);
    }
  }
  {
    auto _e = staticSharedDDRSize();
    _o->staticSharedDDRSize = _e;
  }
  {
    auto _e = dynamicSharedDDRSize();
    _o->dynamicSharedDDRSize = _e;
  }
  {
    auto _e = staticConstantsSize();
    _o->staticConstantsSize = _e;
  }
  {
    auto _e = dynamicConstantsSize();
    _o->dynamicConstantsSize = _e;
  }
  {
    auto _e = exitDoorbellOffset();
    _o->exitDoorbellOffset = _e;
  }
  {
    auto _e = l2CachedDDRSize();
    _o->l2CachedDDRSize = _e;
  }
  {
    auto _e = L2TCMInitSize();
    _o->L2TCMInitSize = _e;
  }
  {
    auto _e = execContextMajorVersion();
    _o->execContextMajorVersion = _e;
  }
  {
    auto _e = numNSPs();
    _o->numNSPs = _e;
  }
  {
    auto _e = numSemaphores();
    _o->numSemaphores = _e;
  }
  {
    auto _e = hwVersionMajor();
    _o->hwVersionMajor = _e;
  }
  {
    auto _e = hwVersionMinor();
    _o->hwVersionMinor = _e;
  }
  {
    auto _e = staticSharedDDRECCEnabled();
    _o->staticSharedDDRECCEnabled = _e;
  }
  {
    auto _e = dynamicSharedDDRECCEnabled();
    _o->dynamicSharedDDRECCEnabled = _e;
  }
  {
    auto _e = staticConstantsECCEnabled();
    _o->staticConstantsECCEnabled = _e;
  }
  {
    auto _e = dynamicConstantsECCEnabled();
    _o->dynamicConstantsECCEnabled = _e;
  }
  {
    auto _e = singleVTCMPage();
    _o->singleVTCMPage = _e;
  }
  {
    auto _e = hasHvxFP();
    _o->hasHvxFP = _e;
  }
  {
    auto _e = hasHmxFP();
    _o->hasHmxFP = _e;
  }
  {
    auto _e = VTCMSize();
    _o->VTCMSize = _e;
  }
  {
    auto _e = L2TCMSize();
    _o->L2TCMSize = _e;
  }
  {
    auto _e = networkHeapSize();
    _o->networkHeapSize = _e;
  }
  {
    auto _e = raw_struct_version_length();
    _o->raw_struct_version_length = _e;
  }
}

inline flatbuffers::Offset<Metadata>
Metadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
               const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Metadata>
CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
               const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const MetadataT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _versionMajor = _o->versionMajor;
  auto _versionMinor = _o->versionMinor;
  auto _networkName =
      _o->networkName.empty() ? 0 : _fbb.CreateString(_o->networkName);
  auto _requiredFields = _o->requiredFields.size()
                             ? _fbb.CreateVectorOfStrings(_o->requiredFields)
                             : 0;
  auto _semaphoreInitState = _o->semaphoreInitState.size()
                                 ? _fbb.CreateVector(_o->semaphoreInitState)
                                 : 0;
  auto _L2TCMInitState =
      _o->L2TCMInitState.size() ? _fbb.CreateVector(_o->L2TCMInitState) : 0;
  auto _dmaRequests =
      _o->dmaRequests.size()
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>>(
                _o->dmaRequests.size(),
                [](size_t i, _VectorArgs *__va) {
                  return CreateAICMDDMARequest(*__va->__fbb,
                                               __va->__o->dmaRequests[i].get(),
                                               __va->__rehasher);
                },
                &_va)
          : 0;
  auto _nspMulticastTables =
      _o->nspMulticastTables.size()
          ? _fbb.CreateVector<flatbuffers::Offset<
                AicMetadataFlat::AICMDNSPMulticastEntryTable>>(
                _o->nspMulticastTables.size(),
                [](size_t i, _VectorArgs *__va) {
                  return CreateAICMDNSPMulticastEntryTable(
                      *__va->__fbb, __va->__o->nspMulticastTables[i].get(),
                      __va->__rehasher);
                },
                &_va)
          : 0;
  auto _hostMulticastTable =
      _o->hostMulticastTable
          ? CreateAICMDHostMulticastEntryTable(
                _fbb, _o->hostMulticastTable.get(), _rehasher)
          : 0;
  auto _threadDescriptors =
      _o->threadDescriptors.size()
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>>(
                _o->threadDescriptors.size(),
                [](size_t i, _VectorArgs *__va) {
                  return CreateAICMDThreadDescriptor(
                      *__va->__fbb, __va->__o->threadDescriptors[i].get(),
                      __va->__rehasher);
                },
                &_va)
          : 0;
  auto _constantMappings =
      _o->constantMappings.size()
          ? _fbb.CreateVector<
                flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>>(
                _o->constantMappings.size(),
                [](size_t i, _VectorArgs *__va) {
                  return CreateAICMDConstantMapping(
                      *__va->__fbb, __va->__o->constantMappings[i].get(),
                      __va->__rehasher);
                },
                &_va)
          : 0;
  auto _staticSharedDDRSize = _o->staticSharedDDRSize;
  auto _dynamicSharedDDRSize = _o->dynamicSharedDDRSize;
  auto _staticConstantsSize = _o->staticConstantsSize;
  auto _dynamicConstantsSize = _o->dynamicConstantsSize;
  auto _exitDoorbellOffset = _o->exitDoorbellOffset;
  auto _l2CachedDDRSize = _o->l2CachedDDRSize;
  auto _L2TCMInitSize = _o->L2TCMInitSize;
  auto _execContextMajorVersion = _o->execContextMajorVersion;
  auto _numNSPs = _o->numNSPs;
  auto _numSemaphores = _o->numSemaphores;
  auto _hwVersionMajor = _o->hwVersionMajor;
  auto _hwVersionMinor = _o->hwVersionMinor;
  auto _staticSharedDDRECCEnabled = _o->staticSharedDDRECCEnabled;
  auto _dynamicSharedDDRECCEnabled = _o->dynamicSharedDDRECCEnabled;
  auto _staticConstantsECCEnabled = _o->staticConstantsECCEnabled;
  auto _dynamicConstantsECCEnabled = _o->dynamicConstantsECCEnabled;
  auto _singleVTCMPage = _o->singleVTCMPage;
  auto _hasHvxFP = _o->hasHvxFP;
  auto _hasHmxFP = _o->hasHmxFP;
  auto _VTCMSize = _o->VTCMSize;
  auto _L2TCMSize = _o->L2TCMSize;
  auto _networkHeapSize = _o->networkHeapSize;
  auto _raw_struct_version_length = _o->raw_struct_version_length;
  return AicMetadataFlat::CreateMetadata(
      _fbb, _versionMajor, _versionMinor, _networkName, _requiredFields,
      _semaphoreInitState, _L2TCMInitState, _dmaRequests, _nspMulticastTables,
      _hostMulticastTable, _threadDescriptors, _constantMappings,
      _staticSharedDDRSize, _dynamicSharedDDRSize, _staticConstantsSize,
      _dynamicConstantsSize, _exitDoorbellOffset, _l2CachedDDRSize,
      _L2TCMInitSize, _execContextMajorVersion, _numNSPs, _numSemaphores,
      _hwVersionMajor, _hwVersionMinor, _staticSharedDDRECCEnabled,
      _dynamicSharedDDRECCEnabled, _staticConstantsECCEnabled,
      _dynamicConstantsECCEnabled, _singleVTCMPage, _hasHvxFP, _hasHmxFP,
      _VTCMSize, _L2TCMSize, _networkHeapSize, _raw_struct_version_length);
}

inline const AicMetadataFlat::Metadata *GetMetadata(const void *buf) {
  return flatbuffers::GetRoot<AicMetadataFlat::Metadata>(buf);
}

inline const AicMetadataFlat::Metadata *
GetSizePrefixedMetadata(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<AicMetadataFlat::Metadata>(buf);
}

inline bool VerifyMetadataBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AicMetadataFlat::Metadata>(nullptr);
}

inline bool VerifySizePrefixedMetadataBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AicMetadataFlat::Metadata>(nullptr);
}

inline void
FinishMetadataBuffer(flatbuffers::FlatBufferBuilder &fbb,
                     flatbuffers::Offset<AicMetadataFlat::Metadata> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMetadataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<AicMetadataFlat::Metadata> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<AicMetadataFlat::MetadataT>
UnPackMetadata(const void *buf,
               const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<AicMetadataFlat::MetadataT>(
      GetMetadata(buf)->UnPack(res));
}

inline std::unique_ptr<AicMetadataFlat::MetadataT> UnPackSizePrefixedMetadata(
    const void *buf, const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<AicMetadataFlat::MetadataT>(
      GetSizePrefixedMetadata(buf)->UnPack(res));
}

} // namespace AicMetadataFlat

#endif // FLATBUFFERS_GENERATED_AICMETADATAFLAT_AICMETADATAFLAT_H_
