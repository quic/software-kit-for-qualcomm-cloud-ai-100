// Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
// SPDX-License-Identifier: BSD-3-Clause-Clear

#ifndef QMETADATA_H
#define QMETADATA_H

#include "QDmaElement.h"
#include "QMetaDataInterface.h"
#include "QLogger.h"
#include "QDevAic100Interface.h"

#include "assert.h"
#include <memory>
#include <tuple>
#include <vector>

namespace qaic {

using QReqElemStencil = std::vector<std::unique_ptr<QDmaRequestElement>>;

/// The vector contains the tuples used to describe a trunk of a buffer.
/// Elements of the tuple: buffer index, offset from the start of
/// the buffer and lastly the size of the trunk.
using QElemToBufVec = std::vector<std::tuple<uint32_t, uint32_t, uint32_t>>;

/// This class stores the stencil generated by QImageParserInterface objects.
/// A stencil contains partially configured request elements which are used
/// as a base for the fully configured request elements.
class QMetaData : public QMetaDataInterface, public QLogger {
public:
  QMetaData(uint32_t numBuf, const QElemToBufVec &bufMap,
            QReqElemStencil stencil)
      : QLogger("QMetaData"), stencil_(std::move(stencil)), numBuf_(numBuf),
        elemToBufVec_(bufMap) {}

  std::unique_ptr<QMetaDataInterface>
  getUpdatedMetadata(uint64_t ddrBase, uint64_t mcIDBase) const override {
    QReqElemStencil stencil;
    for (const auto &item : stencil_) {
      stencil.emplace_back(
          new QDmaRequestElement(*item.get(), ddrBase, mcIDBase));
    }
    auto newMeta = std::unique_ptr<QMetaData>(
        new QMetaData(numBuf_, elemToBufVec_, std::move(stencil)));
    LogDebug("{}", newMeta->getStencilStr());
    return newMeta;
  }

  /// Loop through the elements in the stencil, update target elements with
  /// request ID and buffer address if specified in the stencil
  QStatus updateDmaReqElements(QReqID &reqID, const QBuffer *bufs,
                               uint32_t bufCount, std::vector<uint8_t *> &elems,
                               QReqID &lastReqID) const override {
    if (stencil_.size() > elems.size()) {
      LogError("Expecting space for {} request elements, got only {}",
               stencil_.size(), elems.size());
      return QS_INVAL;
    }
    QReqID i = 0, last = 0;

    for (const auto &item : stencil_) {
      int index = item->getBufIndex();
      bool needResponse = false;

      // Skip reqID of 0
      if (reqID + i == 0) {
        reqID += 1;
      }

      // This item does not have DMA transfer
      if (index == IDX_NO_DMA) {
        item->encodeElement(elems[i], reqID + i);
        i++;
        continue;
      }

      if ((uint32_t)index >= bufCount) {
        LogError("No matching buffer for index {}, total buffers {}", index,
                 bufCount);
        return QS_INVAL;
      }
      // updateElement returns false if the input buffer is not valid,
      // say buffer smaller than required by metadata
      if (!item->encodeElement(elems[i], reqID + i, bufs[index],
                               needResponse)) {
        LogError("Invalid user buffer");
        return QS_INVAL;
      }
      if (needResponse) {
        last = reqID + i;
      }
      i++;
    }
    if (last) {
      lastReqID = last;
    }
    reqID += i;
    return QS_SUCCESS;
  }

  QStatus getDmaDirections(std::vector<QDirection> &dirs, uint32_t total) {
    if (stencil_.size() != total) {
      LogError("Expecting {} request elements, got {}", stencil_.size(), total);
      return QS_INVAL;
    }
    uint count = 0;
    for (const auto &item : stencil_) {
      int index = item->getBufIndex();
      if (index >= (int)total) {
        LogError("Invalid index {} total {}", index, total);
        return QS_INVAL;
      }
      // No DMA
      DmaTransferDirection dir = item.get()->getDmaDirection();
      if (index < 0 || dir == DmaNoTransfer) {
        dirs[count++] = QDirection::QDIR_TO_DEV;
        continue;
      }
      dirs[count] = (dir == DmaInbound ? QDirection::QDIR_TO_DEV
                                       : QDirection::QDIR_FROM_DEV);
      count++;
    }

    if (count != total) {
      LogError("Metadata mistach");
      return QS_INVAL;
    }
    return QS_SUCCESS;
  }

  QStatus updateElementsFromMeta(qaic_attach_slice_entry *attachSliceEntry,
                                 uint32_t start, uint32_t num) const {
    if (stencil_.size() < start + num) {
      LogError("Expecting {} request elements, got {}", stencil_.size(),
               start + num);
      return QS_INVAL;
    }

    for (uint32_t index = 0; index < num; index++) {
      stencil_[start + index]->encodeMem(&attachSliceEntry[index]);
    }
    return QS_SUCCESS;
  }

  uint32_t getReqElementsCount() const override { return stencil_.size(); }
  uint32_t getBufCount() const { return numBuf_; }
  const QElemToBufVec &getElemToBufVec() const { return elemToBufVec_; }

  std::string getStencilStr() const {
    std::stringstream ss;
    for (uint32_t i = 0; i < stencil_.size(); i++) {
      ss << "[" << i << "] " << stencil_[i]->str() << "\n";
    }
    return ss.str();
  }

private:
  /// The stencil contains partially configrued request elements
  const QReqElemStencil stencil_;
  const uint32_t numBuf_;
  const QElemToBufVec elemToBufVec_;
};

} // namespace qaic

#endif // QMETADATA_H
